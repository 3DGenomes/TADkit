(function() {
	'use strict';
	/**
	 * @ngdoc overview
	 * @name TADkit
	 * @module TADkit
	 * @description
	 * Main module for TADkit app.
	 *
	 * @example
	 * <example>
	 * 	<file name="index.html">
	 * 		<div ng-app="TADkit" route-css-classnames>
	 * 			<div data-ui-view id="main" class="fullheight"></div>
	 * 		</div>
	 * 	</file>
	 * </example>
	 *
	 * @requires TADkit.datasets
	 * @requires TADkit.layers
	 * @requires ui.router
	 * @requires ngMaterial
	 * @requires uuid4
	 * @requires d3js
	 * @requires threejs
	 * @requires bioinformatics
	 * @requires browsers
	 * @requires generic
	 * @requires modeling
	 * @requires ui
	 * @requires visualization
	 */
	angular.module('TADkit',['TADkit.datasets','TADkit.layers','ui.router','ngMaterial','uuid4','d3js','threejs','generic','ui','bioinformatics','browsers','modeling','visualization']);
})();
/*
 * This file is generated by Gulp plugin gulp-ng-constant.
 * DO NOT EDIT!
 */
(function() {
'use strict';
angular.module("TADkit")

.constant("NAME", "TADkit")

.constant("VERSION", "0.3.0")

.constant("ENV", "production")

.constant("VERBOSE", false)

.constant("ONLINE", false)

;
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.config(config);

	function config(ENV, $logProvider, $locationProvider, $mdThemingProvider, $provide) {
		$logProvider.debugEnabled(ENV === "development");
		if (ENV === "development") console.log( "TADkit Environment: " + ENV );

		// Removing # from URL with HTML5 History API and
		// add <base href="/myapp/"></base> in index.html
		// Comment to leave # in case of server rewrites.
		// $locationProvider.html5Mode(true);

		// Material Design Themes
		$mdThemingProvider.theme("default")
			.primaryPalette("green")
			.accentPalette("lime", {
				"default": "500"
			})
   			.warnPalette("red")
			.backgroundPalette("grey");
		$mdThemingProvider.theme("darkKit")
			.dark();

		$provide.decorator('mdButtonDirective', ['$delegate',
			function ($delegate) {
				var getTemplate = $delegate[0].template;
				$delegate[0].template = function ($element, $attrs) {
					if ($attrs.type === 'file') {
						return '<label class="md-button" ng-transclude></label>';
					} else {
						return getTemplate($element, $attrs);
					}
				};
				return $delegate;
			}
		]);
		
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.run(run);

	function run(NAME, VERSION, ENV, VERBOSE, ONLINE, $log, $rootScope) {
		$log.info( NAME + " " + VERSION );
		$log.debug( "Environment: " + ENV + ", "  + VERBOSE + ", " + ONLINE + " " );

		$rootScope.$on('$stateChangeError', function (event, toState, toParams, fromState, fromParams, error) {
			$log.error( 'Resolve Error: ', error);
		});
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.config(config);

	function config($stateProvider, $urlRouterProvider) {
		$urlRouterProvider.otherwise("/project/loader/");
		
		$stateProvider
		.state('main', {
			controller: 'MainController',
			abstract: true,
			url: '',
			templateUrl: 'assets/templates/main.html',
			resolve: {
				'initialData': function(App) {
					return new App();
				}
			}
		})
		.state('project', {
			parent: 'main',
			url: '/project',
			data: {
				cssClassnames: 'main'
			},
			views: {
				'topbar@main': {
					templateUrl: 'assets/templates/topbar.html',
					controller: 'TopbarController'
				},
				'sidebar-left@main': {
					templateUrl: 'assets/templates/sidebar.project.html',
					controller: 'ProjectController'
				},
				'content@main': {
					templateUrl: 'assets/templates/project-content.html',
					controller: 'ProjectContentController'
				},
				'sidebar-right@main': {
					templateUrl: 'assets/templates/sidebar.user.html',
					controller: 'SidebarUserController'
				}
			}
		})
		.state('loader', {
			parent: 'project',
			url: '/loader/:loadDataset',
			data: {
				cssClassnames: 'loader'
			},
			views: {
				'topbar@main': {
					templateUrl: 'assets/templates/topbar.html',
					controller: 'TopbarController'
				},
				'content@main': {
					templateUrl: 'assets/templates/project-loader.html',
					controller: 'ProjectLoaderController'
				},
				'sidebar-right@main': {
					templateUrl: 'assets/templates/sidebar.user.html',
					controller: 'SidebarUserController'
				}
			}
		})
		.state('dataset', {
			parent: 'project',
			url: '/dataset',
			data: {
				cssClassnames: 'dataset'
			},
			views: {
				'content@main': {
					templateUrl: 'assets/templates/project-dataset.html',
					controller: 'ProjectDatasetController'
				}
			}
		})
		.state('layer', {
			parent: 'project',
			url: '/layer',
			data: {
				cssClassnames: 'layer'
			},
			views: {
				'content@main': {
					templateUrl: 'assets/templates/project-layer.html',
					controller: 'ProjectController'
				}
			}
		})
		.state('storyboard', {
			parent: 'project',
			url: '/storyboard',
			data: {
				cssClassnames: 'storyboard'
			},
			views: {
				'content@main': {
					templateUrl: 'assets/templates/project-storyboard.html',
					controller: 'ProjectController'
				}
			}
		})
		.state('browser', {
			parent: 'project',
			url: '/browser',
			views: {
				'sidebar-left@main': {
					templateUrl: 'assets/templates/sidebar.browser.html',
					controller: 'SidebarBrowserController'
				},
				'content@main': {
					templateUrl: 'assets/templates/storyboard.html',
					controller: 'StoryboardController'
				}
			}
		})
		.state('data-import', {
			parent: 'browser',
			url: '/data/import',
			views: {
				'modal@main': {
					templateUrl: 'assets/templates/data-import.html',
					controller: 'DataImportController'
				}
			}
		})
		.state('404', {
			url: '/404',
			templateUrl: 'assets/templates/404.tpl.html',
			controller: 'AppController'
		});
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:App
	 * @description Load app and initialize.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://github.com/3DGenomes/angular-threejs
	 * @requires https://github.com/3DGenomes/angular-d3js
	 * @requires TADkit.service:Settings
	 * @requires TADkit.service:Components
	 * @requires TADkit.service:Init
	 */
	angular
		.module('TADkit')
		.factory('App', App);

	function App($log, $q, THREEService, THREETextures, d3Service, Settings, Components, Init) {

		/**
		 * @ngdoc function
		 * @function
		 * @name TADkit.service:App#load
		 * @methodOf TADkit.service:App
		 * @kind function
		 *
		 * @description
		 * Loads app configuration and components.
		 * Waits for promise.
		 *
		 * @requires THREEService
		 * @requires d3Service
		 * @requires TADkit.Settings
		 * @requires TADkit.Components
		 * @requires THREETextures
		 *
		 * @returns {Array} Results of all as promise.
		 */
		function load() {
			$log.debug("Dependencies loading...");

			// Load JS API dependencies
			var three = THREEService.load(); // results[0]
			var d3 = d3Service.load(); // results[1]

			// Load TADKit configuration
			var settings = Settings.load(); // results[2]
			var components = Components.load(); // results[3]

			return $q.all([three, d3, settings, components])
			.then(function(results) {
				$log.debug("Dependencies loaded OK!");
				
				// Load default App textures from Settings
				THREETextures.load(results[2].textures);
				return results;
			});
		}

		/**
		 * @ngdoc function
		 * @name TADkit.service:App#init
		 * @methodOf TADkit.service:App
		 * @kind function
		 *
		 * @description
		 * Initlizes app defaults.
		 * Waits for promise.
		 *
		 * @requires TADkit.Init
		 * @returns {Array} Results of all as promise.
		 */
		function init() {

			var defaults = Init.defaults();

			return $q.all([defaults])
			.then(function(results) {
				return results;
			});
		}

		return function() {
			$log.log("TADkit loading...");

			return load()
			.then(init)
			.then(function() {
				$log.log("TADkit loaded OK!");
			});
		};

	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Components
	 * @description Components for Storyboards.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 * @requires https://github.com/monicao/angular-uuid4
	 *
	 */
	angular
		.module('TADkit')
		.factory('Components', Components);

	function Components($log, $q, $http, uuid4, Settings) {
		var components = {
			loaded : [],
			current : {
				index: 0
			}
		};
		
		return {

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#load
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Loads default components from file.
			 * Waits for promise.
			 *
			 * @requires $log
			 * @requires $q
			 * @requires $http
			 *
			 * @returns {Object} Components as promise.
			 */
			load: function() {
				var deferred = $q.defer();
				var dataUrl = "assets/defaults/tk-defaults-components.json";
				if( components.loaded.length > 0 ) {
					 deferred.resolve(components);
				} else {
					$http.get(dataUrl)
					.success( function(data) {
						components.loaded = data;
						$log.debug("Components (" + data.length + ") loaded from " + dataUrl);
						deferred.resolve(components);
					});
				}
				return deferred.promise;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#add
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Adds component to components Object derived from supplied parameters.
			 * 
			 *
			 * @requires uuid4
			 *
			 * @param {Array} [details] Array of parameters for component.
			 *        [uuid,id,title,type,state{width,height,margin,position},view{}]
			 * @returns {Object} Components Object.
			 */
			add: function(details) {
				details = details || ["","","","","","",[]];
				var component = {
					metadata : {
						version : 1.0,
						type : "component",
						generator : "TADkit"
					},
					object : {
						uuid : uuid4.generate(),
						id : details[0],
						title : details[1],
						type : details[2],
						state : {
							width : details[3],
							height : details[4],
							margin : details[5],
							position : details[6]
						}
					},
					view : details[7]
				};
				components.loaded.push(component);
				components.current = components.loaded.length - 1;
				return components;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#remove
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Removes component from components Object.
			 *
			 * @param {number} [index] Index of component.
			 * @returns {Object} Components Object.
			 */
			remove: function(index) {
				index = index || components.current.index;
				var component = components.loaded.indexOf(index);
				components.loaded.splice(component, 1);
				return components;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#set
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Sets current component.
			 *
			 * @param {number} [index] Index of component.
			 * @returns {Object} The current component.
			 */
			set: function(index) {
				if (index !== undefined || index !== false) components.current.index = index;
				var component = components.loaded[components.current.index];
				return component;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#init
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Initializes component.
			 *
			 * @param {number} [index] Index of component.
			 * @returns {Object} Components.
			 */
			init: function(index) {
				// W.I.P.
				// index = index || components.current.index;
				// var component = components.loaded.indexOf(index);
				// var chromStart = chromStart || 0;
				// var chromEnd = chromEnd || 4999999;
				// var scale = scaleOrig || 1;
				// component.view.viewpoint.chromStart = chromStart;
				// component.view.viewpoint.chromEnd = chromEnd;
				// if (component.object.type === "scene" || component.object.type === "scene-clusters") {
				// 	// For 3D scenes, so as to view whole object for a given FOV:
				// 	// Scale * radius of object = translation from orgin of object
				// 	var angle = component.view.viewpoint.fov / 2;
				// 	scale = Math.tan(angle).toFixed(2);
				// 	$log.debug(scale);
				// }
				// component.view.viewpoint.scale = scale;
				$log.info("Component initialized!");
				return components;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#setViewpoint
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Adds component to components Object.
			 *
			 * @requires uuid4
			 *
			 * @param {number} chromStart Viewpoint start of component.
			 * @param {number} chromEnd Viwepoint end coordinate of component.
			 * @param {number} scaleOrig Viewpoint scale of component.
			 * @returns {Object} Components.
			 */
			// setViewpoint: function(chrom, chromStart, chromEnd, scaleOrig) {
			// 	chrom = chrom || "1";
			// 	chromStart = chromStart || 0;
			// 	chromEnd = chromEnd || 4999999;
			// 	var currentComponents = components.loaded;
			// 	angular.forEach(currentComponents, function(component, index) {
			// 		var scale = scaleOrig || 1;
			// 		component.view.viewpoint.chrom = chrom;
			// 		component.view.viewpoint.chromStart = chromStart;
			// 		component.view.viewpoint.chromEnd = chromEnd;
			// 		if (component.object.type === "scene" || component.object.type === "scene-clusters") {
			// 			/* For 3D scenes, so as to view whole object for a given FOV:
			// 			 * Scale * radius of object = translation from orgin of object
			// 			 * See ... service.
			// 			 */
			// 			var angle = component.view.viewpoint.fov / 2;
			// 			scale = Math.tan(angle).toFixed(2);
			// 		}
			// 		component.view.viewpoint.scale = scale;
			// 	});
			// 	return components;
			// },

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#get
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Get components Object.
			 *
			 * @param {Array} [list] Array of components to get.
			 * @returns {Object} Components.
			 */
			get: function(list) {
				list = list || [];
				var collection = [];
				if (list.length > 0) {
					for (var i = list.length - 1; i >= 0; i--) {
						var id = list[i];
						for (var j = components.loaded.length - 1; j >= 0; j--) {
							var component = components.loaded[j];
							if (component.object.id === id) {
								collection.unshift(component);
								break;
							}
						}
						// if (collection.length === 0) $log.warn("Component id '" + id + "' not found.");
					}
					// if (collection.length > 0) $log.warn("No components loaded.");
				} else {
					// return all components
					collection = components.loaded;
				}
				return collection;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#getComponent
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Get component from components Object. Returns current component if no component index supplied.
			 *
			 * @param {number} [index] Index of component.
			 * @returns {Object} Component.
			 */
			getComponent: function(index) {
				if (index === undefined || index === false) index = components.current.index;
				var component = components.loaded[index];
				return component;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#getComponentById
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Get component from components Object by ID (required).
			 *
			 * @param {number} id Component ID (Note: not component index).
			 * @returns {Object} Component if found.
			 */
			getComponentById: function(id) {
				var component, found;
				if (id !== undefined || id !== false) {
					for (var i = components.loaded.length - 1; i >= 0; i--) {
						if (components.loaded[i].object.id === id) {
							component = components.loaded[i];
							found = i;
							$log.debug("Component '" + id + "' found!");
						}
					}
				} else {
					return $log.warn("No valid component ID supplied.");
				}
				if (!found) {
					component = components.loaded[components.current.index];
					$log.warn("Component '" + id + "' not found: returning current.");
				}
				return component;
			},
			// OLD VERSION FROM STORYBOARDS WITH INDEX
			// getComponentById: function (id) {
			// 	var self = this;
			// 	var component, found;
			// 	var components = self.getStoryboard().components;
			// 	if (id !== undefined || id !== false) {
			// 		for (var i = components.length - 1; i >= 0; i--) {
			// 			$log.debug(components[i].object.title);
			// 			if (components[i].object.title === id) {
			// 				component = components[i];
			// 				component.index = i;
			// 				found = true;
			// 				$log.debug("Component '" + id + "' found");
			// 			}
			// 		}
			// 	}
			// 	if (!found) {
			// 		component = components[0];
			// 		$log.warn("Component '" + id + "' not found: returning first.");
			// 	}
			// 	$log.debug(component);
			// 	return component;
			// }

			/**
			 * @ngdoc function
			 * @name TADkit.service:Components#getComponentByType
			 * @methodOf TADkit.service:Components
			 * @kind function
			 *
			 * @description
			 * Get component from components Object by Type (required),
			 *
			 * @param {number} id Component ID (Note: not component index).
			 * @returns {Object} Component if found.
			 */
			getComponentByType: function (type) {
				var self = this;
				var component, defaultComponent, found;
				if (type !== undefined || type !== false) {
					for (var i = components.loaded.length - 1; i >= 0; i--) {
						if (components.loaded[i].object.type === type) {
							component = components.loaded[i];
							found = i;
							$log.debug("Component type '" + type + "' found!");
						}
						if (components.loaded[i].object.type === "default") {
							defaultComponent = components.loaded[i];
						}
					}
				}
				if (!found) {
					component = defaultComponent;
					$log.warn("Component type '" + type + "' not found: returning default.");
				}
				self.init(component);
				return component;
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Init
	 * @description Initialize default Objects.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires TADkit.service:Users
	 * @requires TADkit.service:Projects
	 * @requires TADkit.service:Datasets
	 * @requires TADkit.service:Layers
	 * @requires TADkit.service:Storyboards
	 * @requires TADkit.service:Proximities
	 * @requires TADkit.service:Restraints
	 * @requires TADkit.service:EnsemblColors
	 *
	 */
	angular
		.module('TADkit')
		.factory('Init', Init);

	function Init($log, $q, Users, Projects, Datasets, Clusters, Layers, DataImport, Storyboards, Settings, Proximities, Restraints, EnsemblColors) {

		/**
		 * @ngdoc function
		 * @name TADkit.service:Init#buildUserHierarchy
		 * @methodOf TADkit.service:Init
		 * @kind function
		 *
		 * @description
		 * Build app Object hierarchy ie. User > Projects > [Datasets | Layers | Storyboards]
		 *
		 * @requires $log
		 * @requires TADkit.service:Users
		 * @requires TADkit.service:Projects
		 * @requires TADkit.service:Datasets
		 * @requires TADkit.service:Layers
		 * @requires TADkit.service:Storyboards
		 *
		 */
		function buildUX() {
			$log.debug("Default user initializing...");

			// BUILD DEFAULT DATA HIERARCHY
			// User >> Projects >> Datasets | Layers | Storyboards
			var user = Users.getUser();
			if (typeof user.projects !== "undefined" && user.projects.length === 0) {
				user.projects = Projects.get();
				if (typeof user.projects.loaded[0].datasets !== "undefined" &&  user.projects.loaded[0].datasets.length === 0)
					user.projects.loaded[0].datasets = Datasets.get();
				if (typeof user.projects.loaded[0].layers !== "undefined" &&  user.projects.loaded[0].layers.length === 0)
					user.projects.loaded[0].layers = Layers.get();
				if (typeof user.projects.loaded[0].storyboards !== "undefined" &&  user.projects.loaded[0].storyboards.length === 0)
					user.projects.loaded[0].storyboards = Storyboards.get();
			}
			$log.debug("User interface initialized.");
		}

		/**
		 * @ngdoc function
		 * @name TADkit.service:Init#setDefaultDataset
		 * @methodOf TADkit.service:Init
		 * @kind function
		 *
		 * @description
		 * Set default dataset.
		 *
		 * @requires $log
		 * @requires TADkit.service:Datasets
		 * @requires TADkit.service:Proximities
		 * @requires TADkit.service:Restraints
		 * @requires TADkit.service:EnsemblColors
		 *
		 */
		function setDefaultDataset() {
			$log.debug("Default dataset initializing...");

			var currentDataset = Datasets.getDataset();
			
			Clusters.load(currentDataset);
			var currentModelData = Clusters.getModelData();
			Settings.set(currentDataset);
			var distances = Proximities.set(currentModelData).distances;
			var datasetDimension = currentModelData.length / 3; // 3 == xyz components of vertices
			var restraints = Restraints.set(currentDataset.restraints, datasetDimension);

			// Update Layers for initialized Dataset.
			var layersUpdate = Layers.update(distances, restraints);

			return $q.all([layersUpdate])
			.then(function() {
				$log.debug("Default dataset initialized.");
			});
		}

		return {

			/**
			 * @ngdoc function
			 * @name TADkit.service:Init#defaults
			 * @methodOf TADkit.service:Init
			 * @kind function
			 *
			 * @description
			 * Initalizes appw.
			 *
			 * @requires $log
			 * @requires TADkit.service:Users
			 * @requires TADkit.service:Projects
			 * @requires TADkit.service:Datasets
			 * @requires TADkit.service:Datasets
			 * @requires TADkit.service:EnsemblColors
			 *
			 * @returns {Object} All loaded defaults.
			 */
			defaults: function() {
				$log.debug("Defaults initializing...");

				// Load TADKit defaults from JSON files
				var users = Users.load();
				var projects = Projects.load();
				var datasets = Datasets.load();
				var layers = Layers.load();
				var storyboards = Storyboards.load();
				var features = EnsemblColors.load();

				return $q.all([users, projects, datasets, layers, storyboards, features])
				.then(buildUX)
				.then(setDefaultDataset)
				.then(function() {
				$log.debug("Defaults initialized.");
				});
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Projects
	 * @description Projects of Users.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 * @requires https://github.com/monicao/angular-uuid4
	 *
	 */
	angular
		.module('TADkit')
		.factory('Projects', Projects);

	function Projects($log, $q, $http, uuid4) {
		var projects = {
			loaded : [],
			current : {
				index: 0
			}
		};

		return {
			load: function() {
				var deferred = $q.defer();
				var dataUrl = "assets/defaults/tk-defaults-projects.json";
				if( projects.loaded.length > 0 ) {
					 deferred.resolve(projects);
				} else {
					$http.get(dataUrl)
					.success( function(data) {
						projects.loaded = data;
						$log.debug("Projects (" + data.length + ") loaded from " + dataUrl);
						 deferred.resolve(projects);
					});
				}
				return deferred.promise;
			},
			add: function(details) {
				var newProject = {
					metadata : {
						version : 1.0,
						type : "project",
						generator : "TADkit"
					},
					object : {
						uuid : uuid4.generate(),
						id : details[0],
						title : details[1],
						description : details[2],
						group : details[3],
						state : details[4]
					},
					datasets : details[5],
					layers : details[6],
					storyboards : details[7]
				};
				projects.loaded.push(newProject);
				projects.current = projects.loaded.length - 1;
				return projects;
			},
			remove: function(index) {
				if (index === undefined || index === false) index = projects.current.index;
				var project = projects.loaded.indexOf(index);
				projects.loaded.splice(project, 1);
				return projects;
			},
			set: function(index) {
				if (index !== undefined || index !== false) projects.current.index = index;
				var current = projects.loaded[projects.current.index];
				return current;
			},
			get: function() {
				return projects;
			},
			getProject: function(index) {
				if (index === undefined || index === false) index = projects.current.index;
				var project = projects.loaded[index];
				return project;
			},
			getState: function(index) {
				if (index === undefined || index === false) index = projects.current.index;
				var state = projects.loaded[index].object.state;
				return state;
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Settings
	 * @description Settings of App.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 *
	 */
	angular
		.module('TADkit')
		.factory('Settings', Settings);

	function Settings(ONLINE, $log, $q, $http) {
		var settings = {};

		return {
			load: function() {
				var deferred = $q.defer();
				var dataUrl = "assets/defaults/tk-defaults-settings.json";
				if( Object.getOwnPropertyNames(settings).length > 0 ) {
					 deferred.resolve(settings);
				} else {
					$http.get(dataUrl)
					.success( function(data) {
						settings = data;
						$log.debug("Settings loaded from " + dataUrl);
						 deferred.resolve(settings);
					});
				}
				return deferred.promise;
			},
			set: function(dataset) {
				var self = this;
				var chromosomeIndex = 0;
				if (dataset.object.chromosomeIndex) { chromosomeIndex = dataset.object.chromosomeIndex;	}
				settings.current.chrom = dataset.object.species;
				settings.current.chrom = dataset.object.chrom[chromosomeIndex];
				settings.current.chromStart = dataset.object.chromStart[chromosomeIndex];
				settings.current.chromEnd = dataset.object.chromEnd[chromosomeIndex];
				settings.current.species = dataset.object.species;
				settings.current.speciesUrl = dataset.object.speciesUrl;
				// NOTE: particle segements as lowest resolution of model
				// instead of particleSegments as variable in TADkit
				// i.e settings.current.particleSegments = storyboard.components[0].view.settings.chromatin.particleSegments;
				settings.current.particleSegments = 20;// ((dataset.object.chromEnd - dataset.object.chromStart) / dataset.object.resolution);
				settings.current.particlesCount = dataset.models[0].data.length / dataset.object.components;
				settings.current.edgesCount = ((settings.current.particlesCount*settings.current.particlesCount)-settings.current.particlesCount)*0.5;
				settings.current.segmentsCount = settings.current.particlesCount * settings.current.particleSegments;
				// NOTE: segmentLength can be calculated in 2 ways:
				// 1. particleResolution (TADbit data) / particleSegments (TADkit setting)
				// 2. modelResolution (TADbit chromEnd - TADbit chromStart) / segmentsCount
				// Method 1. is used as it is simpler to calculate and the data is already loaded.
				// Also focus on particles and does not address rounding off of sequence length.
				settings.current.segmentLength = dataset.object.resolution / settings.current.particleSegments; // base pairs
				// SET INITIAL position at midpoint
				settings.current.position = settings.current.chromStart + parseInt((settings.current.chromEnd - settings.current.chromStart) * 0.5);
				settings.current.particle = self.getParticle();
				// AND SEGMENT IT LIES WITHIN
				settings.current.segment = self.getSegment(settings.current.position);
				settings.current.segmentLower = settings.current.position - (settings.current.segment * 0.5);
				settings.current.segmentUpper = settings.current.position + (settings.current.segment * 0.5);
			},
			setOnline: function(online) {
				online = online || ONLINE; // if no param use Constant
				settings.app.online = online;
				return settings.online;
			},
			add: function(setting) {
				// // rewrite for Object
				// settings.push(settingID);
				return settings;
			},
			remove: function(setting) {
				// // rewrite for Object
				// var index = settings.indexOf(settingID);
				// settings.splice(index, 1);
				return settings;
			},
			getState: function(setting) {
				var settingState = settings[settingID].state;
				return settingState;
			},
			get: function() {
				return settings;
			},
			getOnline: function() {
				var online = false;
				if (settings.app) {
					online = settings.app.online;
				} else {
					online = ONLINE;
				}
				return online;
			},
			getAddress: function() {
				var address = {};
					address.species = settings.current.species;
					address.speciesUrl = settings.current.speciesUrl;
					address.chrom = settings.current.chrom;
					address.chromStart = settings.current.chromStart;
					address.chromEnd = settings.current.chromEnd;
				return address;
			},
			getSegment: function(chromPosition) {
				chromPosition = chromPosition || settings.current.position;
				var self = this;
				var chromOffset = self.getRange(settings.current.chromStart, chromPosition);
				var chromRange = self.getRange(settings.current.chromStart, settings.current.chromEnd);
				var segment = Math.ceil((chromOffset * settings.current.segmentsCount) / chromRange);
				return segment;
			},
			getParticle: function(chromPosition) {
				chromPosition = chromPosition || settings.current.position;
				var self = this;
				var chromOffset = self.getRange(settings.current.chromStart, chromPosition);
				var chromRange = self.getRange(settings.current.chromStart, settings.current.chromEnd);
				var particle = Math.ceil((chromOffset * settings.current.particlesCount) / chromRange);
				return particle;
			},
			getRange: function(start, end) {
				var range = 0;
				for (var i = start; i <= end; i++) {
					range++;
				}
				return range;
			},
			toggle: function(selected) {
				// settings = $filter('filter')(settings, {name: '!settingID'}) // USE THIS???
				angular.forEach(settings, function(name, setting) {
					if (selected == name.id) {
						name.state = !name.state;
					}
				});
				return settings;
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Storyboards
	 * @description Storyboards of Projects.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 * @requires https://github.com/monicao/angular-uuid4
	 * @requires TADkit.service:Settings
	 * @requires TADkit.service:Components
	 *
	 */
	angular
		.module('TADkit')
		.factory('Storyboards', Storyboards);

	function Storyboards(VERBOSE, $log, $q, $http, uuid4, Settings, Components) {
		var storyboards = {
			loaded : [],
			current : {
				index: 0
			}
		};
		
		return {
			load: function() {
				var deferred = $q.defer();
				var dataUrl = "assets/defaults/tk-defaults-storyboards.json";
				if( storyboards.loaded.length > 0 ) {
					$log.warn("Storyboards already loaded.");
					 deferred.resolve(storyboards);
				} else {
					$http.get(dataUrl)
					.success( function(data) {
						storyboards.loaded = data;
						$log.debug("Storyboards (" + data.length + ") loaded from " + dataUrl);
						 deferred.resolve(storyboards);
					});
				}
				return deferred.promise;
			},
			add: function(details) {
				details = details || [""];
				var storyboard = {
					metadata : {
						version : 1.0,
						type : "storyboard",
						generator : "TADkit"
					},
					object : {
						uuid : uuid4.generate(),
						id : details[0],
						title : details[1],
						email : details[2],
						group : details[3],
						permissions : details[4]
					},
					data : details[5]
				};
				storyboards.loaded.push(storyboard);
				storyboards.current = storyboards.loaded.length - 1;
				return storyboards;
			},
			addComponent: function(layer, storyboardId, options) {
				var self = this;
				storyboardId = storyboardId || "default";
				options = options || [];

				var settings = Settings.get();
				// Add a preconfigured conponent from Components
				// - update with options if necessary
				var componentTemplate = Components.getComponentByType(layer.object.type);
				// New component for layer
				var newComponent = angular.copy(componentTemplate);
					newComponent.object.uuid = uuid4.generate();
					newComponent.object.id = layer.object.id;
					newComponent.object.title = layer.object.id;
					newComponent.object.dataset = layer.object.id;
					newComponent.view.settings.step = layer.object.step;
					newComponent.view.settings.color = layer.object.color;
					newComponent.view.viewpoint.species = settings.current.species;
					newComponent.view.viewpoint.chrom = settings.current.chrom;
					newComponent.view.viewpoint.chromStart = settings.current.chromStart;
					newComponent.view.viewpoint.chromEnd = settings.current.chromEnd;
					newComponent.view.viewpoint.scale = settings.views.scale;
					newComponent.view.viewtype = layer.object.type + "-" + layer.object.stepType;
					newComponent.data = layer.data;
					newComponent.layer = layer;

				var storyboard = self.getStoryboardById(storyboardId);
				storyboard.components.push(newComponent);
				return newComponent;
			},
			defaultComponents: function(storyboardId) {
				var self = this;
				storyboardId = storyboardId || "current";
				var storyboard;
				if (storyboardId == "current")Â {
					storyboard = self.getStoryboard();
				} else {
					storyboard = self.getStoryboardById(storyboardId);					
				}
				while (storyboard.components.length > 6) { // remove all except defaults
					$log.warn("Popping to default components...");
					storyboards.loaded[storyboards.current.index].components.pop();
				}
				return storyboards;
			},
			remove: function(index) {
				if (index === undefined || index === false) index = storyboards.current.index;
				var storyboard = storyboards.loaded.indexOf(index);
				storyboards.loaded.splice(storyboard, 1);
				return storyboards;
			},
			removeComponentById: function(id) {
				var self = this;
				if (id !== undefined || id !== false) {
					var storyboard = self.getStoryboard();
					storyboard.components.splice(component.index, 1);
				}
				return storyboards;
			},
			set: function(index) {
				if (index !== undefined || index !== false) storyboards.current.index = index;
				var storyboard = storyboards.loaded[storyboards.current.index];
				return storyboard;
			},
			setComponents: function() {
				var self = this;
				var storyboard = self.getStoryboard();
				var components = Components.get(storyboard.componentList);
				storyboard.components = components;
				return components;
			},
			setViewpoint: function() {
				var settings = Settings.get();
				var currentComponents = storyboards.loaded[storyboards.current.index].components;
				if (VERBOSE) $log.debug(currentComponents);
				angular.forEach( currentComponents, function(component, index) {
					var scale = settings.views.scale || 1;
					component.view.viewpoint.species = settings.current.species;
					component.view.viewpoint.chrom = settings.current.chrom;
					component.view.viewpoint.chromStart = settings.current.chromStart;
					component.view.viewpoint.chromEnd = settings.current.chromEnd;
					if (component.object.type === "scene" || component.object.type === "scene-clusters") {
						var angle = component.view.viewpoint.fov / 2;
						var margin = 0.6;
						scale = Math.tan(angle).toFixed(2) * margin;
					}
					component.view.viewpoint.scale = scale;
				});
				return storyboards;
			},
			update: function(layer) {
				var self = this;
				var components = self.getStoryboard().components;
				// Assign data and layers for each component by type
				angular.forEach(components, function(component, index) {
					// if (component.object.dataset == "default") {
						var layerProximities;
						// if (component.object.type == "scene") {
						// 	component.data = $scope.current.model.data;
						// 	 // component.proximities required for Scenes: layer.colors Saturation
						// 	component.proximities = $scope.allProximities;
						// 	component.layer = $scope.current.layer;
						// 	component.layer.state = {};
						// 	component.layer.object.state.index = Layers.getCurrentIndex();
						// } else if (component.object.type == "track-genes" || component.object.type == "panel-inspector") {
						if (component.object.type == "track-genes" || component.object.type == "panel-inspector") {
							component.data = layer.data;
							// component.layer required for toggle
							component.layer = layer;
						}
						// } else if (component.object.type == "track-proximities") {
						// 	// ie only one... see note above for Calculating Proximities
						// 	// component.data for Scenes: layer.colors Saturation
						// 	component.data = $scope.currentProximities;
						// 	// component.layer required for toggle
						// 	//   and for Scenes: layer.colors Hue
						// 	layer = Layers.getLayerById("proximities");
						// 	component.layer = layer;
						// } else if (component.object.type == "track-restraints") {
						// 	// ie only one... see note above for Calculating Restraints
						// 	// component.data for Scenes: layer.colors Saturation
						// 	component.data = $scope.currentRestraints;
						// 	// component.layer required for toggle
						// 	//   and for Scenes: layer.colors Hue
						// 	layer = Layers.getLayerById("restraints");
						// 	component.layer = layer;
						// }
						// } else if (component.object.type == "track-wiggle") {
						// 	layer = Layers.getLayerById(component.object.dataset);
						// 	component.data = layer.data;
						// 	component.layer = layer; // required for toggle
						// } else {
						// 	// slider and other types of component...
						// }
					// }
				});
			},
			get: function() {
				return storyboards;
			},
			getStoryboard: function(index) {
				if (index === undefined || index === false) index = storyboards.current.index;
				var storyboard = storyboards.loaded[index];
				return storyboard;
			},
			getStoryboardById: function (id) {
				var storyboard, found;
				if (id !== undefined || id !== false) {
					for (var i = storyboards.loaded.length - 1; i >= 0; i--) {
						if (storyboards.loaded[i].object.id === id) {
							storyboard = storyboards.loaded[i];
							storyboard.index = i;
							found = true;
							$log.debug("Layer \"" + id + "\" found!");
						}
					}
				}
				if (!found) {
					storyboard = storyboards.loaded[storyboards.current.index];
					storyboard.index = storyboards.current.index;
					$log.warn("Storyboard '" + id + "' not found: returning current.");
				}
				return storyboard;
			},
			getComponents: function() {
				var self = this;
				var components = self.getStoryboard().components;
				return components;
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Users
	 * @description Users of App.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 * @requires https://github.com/monicao/angular-uuid4
	 *
	 */
	angular
		.module('TADkit')
		.factory('Users', Users);

	function Users($log, $q, $http, uuid4) {
		var users = {
			loaded : [],
			current : {
				index: 0
			}
		};

		return {
			load: function() {
				var deferred = $q.defer();
				var dataUrl = "assets/defaults/tk-defaults-users.json";
				if( users.loaded.length > 0 ) {
					 deferred.resolve(users);
				} else {
					$http.get(dataUrl)
					.success( function(data) {
						users.loaded = data;
						$log.debug("Users (" + data.length + ") loaded from " + dataUrl);
						 deferred.resolve(users);
					});
				}
				return deferred.promise;
			},
			add: function(details) {
				details = details || ["id", "Name Surname", "email@company.com", "Group", "edit", ["default"]];
				var user = {
					metadata : {
						version : 1.0,
						type : "user",
						generator : "TADkit"
					},
					object : {
						uuid : uuid4.generate(),
						id : details[0],
						title : details[1],
						email : details[2],
						group : details[3],
						permissions : details[4]
					},
					projects : details[5]
				};
				users.loaded.push(user);
				users.current = users.loaded.length - 1;
				return users;
			},
			remove: function(index) {
				if (index === undefined || index === false) index = users.current.index;
				var user = users.loaded.indexOf(index);
				users.loaded.splice(user, 1);
				return users;
			},
			set: function(index) {
				if (index !== undefined || index !== false) users.current.index = index;
				var current = users.loaded[users.current.index];
				return current;
			},
			get: function() {
				return users;
			},
			getUser: function(index) {
				if (index === undefined || index === false) index = users.current.index;
				var user = users.loaded[index];
				return user;
			},
			getPermissions: function(index) {
				if (index === undefined || index === false) index = users.current.index;
				var permissions = users.loaded[index].permissions;
				return permissions;
			}
		};
	}
})();
(function () {
	'use strict';
	/**
	 * @ngdoc overview
	 * @name datasets
	 * @module datasets
	 * @description
	 * Datasets Module
	 * Contains datasets scripts which are essential to the TADkit App.
	 *
	 * @example
	 * `angular.module('myApp',['takit.datasets']);`
	 *
	 */
	angular
		.module('TADkit.datasets', []);
}());
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:DataImport
	 * @description Import datasets to Projects.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 *
	 */
	angular
		.module('TADkit.datasets')
		.factory('DataImport', DataImport);

	function DataImport(VERSION, NAME, $log, Clusters, Layers) {
		// Import additional 2D/track data imported by users for use as Layers

		return {
			/**
			 * @ngdoc function
			 * @name TADkit.service:DataImport#import
			 * @methodOf TADkit.service:DataImport
			 * @kind function
			 *
			 * @description Process for importing data
			 *
			 * @param {Object} data Data Object.
			 * @returns {Object} Datasets Object.
			 */
			import: function(data) {
				data = data || {}; // validate data???
				var self = this;
				var dataset = {};

				// data is JSON string to be serialized
				if (!angular.isObject(data)) data = angular.fromJson(data);

				if (data.metadata && data.metadata.type == "dataset" && data.metadata.generator == "TADbit") {
						dataset = data; // already a TADkit Object
						dataset.object = self.detail(data);
				} else {
					// Deal with errors from PapaParse
					// Check parsedData is TABULAR data
					var validatedData = self.validate(data.data);
					var filteredData = self.filter(validatedData, data.selection);
					var dataDetails = self.detail(data);
					dataset = self.create(filteredData, dataDetails);
				}

				if (dataset.clusters) {
					console.log("Clusters found :)");
					Clusters.load(dataset);
				} else {
					console.log("No clusters :(");
					// HACK: assuming tabular data import...
					Layers.import(dataset);
				}

				return dataset;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:DataImport#parse
			 * @methodOf TADkit.service:DataImport
			 * @kind function
			 *
			 * @description Parse file data into JSON object
			 *
			 * @param {Object} data Data Object.
			 * @returns {Object} Datasets Object.
			 */
			parse: function(data) {
				Papa.DefaultDelimiter = " ";
				var parsedData = Papa.parse(data,{
					dynamicTyping: true,
					skipEmptyLines: true,
					fastMode: true
				});
				return parsedData.data;
			},
			
			/**
			 * @ngdoc function
			 * @name TADkit.service:DataImport#validate
			 * @methodOf TADkit.service:DataImport
			 * @kind function
			 *
			 * @description
			 * check with User feedback... first row pulldown
			 * is it a set of xyz, scores, imaging data, ...
			 * is it a point cloud, an array....
			 * note a matrix is a ???
			 * if isNumber also check if integer or float
			 * if col2 integer check that is higher than col1
			 * if yes use as coordinates...
			 * 1D(e.g numerals, strings etc)
			 * 2D(e.g. pixel color info of an image)
			 * 3D(e.g data table)
			 * or any n Dimensions.
			 * if not classify as value... but check with User feedback
			 *
			 * @param {Object} data Data Object.
			 * @returns {Object} Datasets Object.
			 */
			validate: function(data) {
				var valid = true;
				// var rows = data.length;
				// var cols = data[0].length;
				var validatedData;


				// for (var i = 0; i < rows; i++) {
				// 	var newRow = [];
				// 	if (selectedRows[i]) {
				// 		for (var j = 0; j < cols; j++) {
				// 			if (selectedCols[j]) newRow.push(dataTable[i][j]); // else column not added
				// 		}
				// 		filteredData.push(newRow);
				// 	} // else row not added
				// 	valid = true;
				// }
				validatedData = data;
				if (valid) {
					return validatedData;
				} else {
					// give error message
					// return to Project Loader page
				}
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:DataImport#filter
			 * @methodOf TADkit.service:DataImport
			 * @kind function
			 *
			 * @description
			 * data [[row1col1,row1col2...],[row2col1,row2col2...]...]
			 * Remove rows/cols marked false in selection.rows/.cols arrays
			 *
			 * @param {Object} data Data Object.
			 * @returns {Object} Datasets Object.
			 */
			filter: function(data, selection) {
				var filteredData = [];
				if (selection.rows.length === 0 && selection.cols.length === 0) {
					filteredData = data;
				} else {
					var rows = selection.rows.length;
					var cols = selection.cols.length;
					for (var i = 0; i < rows; i++) {
						var newRow = [];
						if (selection.rows[i]) {
							for (var j = 0; j < cols; j++) {
								if (selection.cols[j]) newRow.push(data[i][j]);
								// else column ignored
							}
							filteredData.push(newRow);
						} // else row not added
					}
				}
				return filteredData;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:DataImport#describe
			 * @methodOf TADkit.service:DataImport
			 * @kind function
			 *
			 * @description
			 * Formats data for dataset.
			 *
			 * @param {Object} details Data Object.
			 * @returns {Object} Formatted data.
			 */
			detail: function(preview) {
				var details = {};
				if (preview.object) {
					// already a dataset with details in data.object
					details = preview.object;
				} else {
					var defaults = {
						"uuid" : "00000000-0000-0000-0000-000000000000",
						"id" : "default",
						"title" : "Default",
						"description" : "Default description",

						"source" : "Default",
						"assembly" : "Default",
						"experimentType" : "Default",
						"project" : "Default",

						"domain" : "Default",
						"organism" : "Default",
						"species" : "Default",
						"cellType" : "Default",

						// "locus" : {
							"chrom" : ["X"], // scaffold/landmarks
							"chromStart" : [0], // start
							"chromEnd" : [1000], // end								
						// }
						// "datatype" : {
							"resolution" : 1000,
							"datatype" : "default",
							"components" : 2, // for data parsing										
						// }
						"dependencies" : {}
					};
					details = defaults;
					// angular.extend(this, angular.copy(defaults), details);
				}
				var species = details.species;
				var speciesUrl = species.replace(/[^a-z0-9]/gi, '_').toLowerCase();
				details.speciesUrl = speciesUrl;
				for (var i = details.chrom.length - 1; i >= 0; i--) {
					details.chrom[i].toLowerCase();
				}
				details.region = details.chrom + ":" + details.chromStart + "-" + details.chromEnd;
				return details;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:DataImport#create
			 * @methodOf TADkit.service:DataImport
			 * @kind function
			 *
			 * @description Create new dataset object
			 *
			 * @param {Object} data Data Object.
			 * @returns {Object} Datasets Object.
			 */
			create: function(data, details) {
				var dataset = {
						"metadata": {
							"version" : VERSION,
							"type" : "dataset",
							"generator" : NAME
						},
						"object" : details,
						"data" : data
					};
				return dataset;
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Datasets
	 * @description Datasets of Projects.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 * @requires https://github.com/monicao/angular-uuid4
	 *
	 */
	angular
		.module('TADkit.datasets')
		.factory('Datasets', Datasets);

	function Datasets(VERBOSE, $log, $q, $http, uuid4, DataImport) {
		var datasets = {
			loaded : [],
			current : {
				index : 0,
			}
		};
		return {
			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#load
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Loads Datset from supplied file or default.
			 * Waits for promise.
			 *
			 * @requires $log
			 * @requires $q
			 * @requires $http
			 *
			 * @param {string} [filename] Filename for file of type JSON and extension .json.
			 * @param {boolean} [clear] Clear loaded datasets.
			 * @returns {Object} Datasets as resolved promise.
			 */
			load: function(filename, clear) {
				filename = filename || "tk-example-dataset";
				clear = clear || false;
				var self = this;
				if (clear) self.clear();

				var datapath = "examples";

				var deferred = $q.defer();
				var dataUrl = "assets/" + datapath + "/" + filename + ".json";
				$http.get(dataUrl)
				.success( function(dataset) {
					// TADkit defaults and examples are already validated
					dataset.object.filename = filename;
					self.import(dataset);
					deferred.resolve(datasets);
				});
				return deferred.promise;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#import
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Imports supplied data and adds to Datasets.
			 *
			 * @requires $log
			 *
			 * @param {Object} data Data Object.
			 * @returns {Object} Datasets Object.
			 */
			preview: function(data, selection) {
				var preview = {
					"data" : {},
					"selection" : {
						"rows" : [],
						"cols" : []
					},
					"details" : {

					}
				};
				preview.data = DataImport.parse(data);
				// Selected Rows in File Data
				// Controlled by checkboxes in data-import.html
				var rows = preview.data.length;
				while (--rows >= 0) {preview.selection.rows[rows] = true;} // on init select all
				// Selected Columns in File Data
				// Controlled by checkboxes in data-import.html
				var cols = preview.data[0].length;
				while (--cols >= 0) {preview.selection.cols[cols] = true;} // on init select all
				return preview;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#import
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Imports previewed data and adds to Datasets.
			 *
			 * @requires $log
			 *
			 * @param {Object} data Preview data Object.
			 * @returns {Object} Datasets Object.
			 */
			import: function(data) {
				data = data || "error"; // Handle error
				var self = this;
				var dataset = DataImport.import(data);
				dataset = self.unique(dataset);
				self.add(dataset);
				return dataset;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#unique
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Check the data and ID are unique in Datasets.
			 *
			 * @requires $log
			 *
			 * @param {Object} dataset Dataset Object.
			 * @returns {Object} Datasets Object.
			 */
			unique: function(dataset) {
				var timeout = 1000;
				var unique = false;
				if (datasets.loaded.length > 0) {
					while (timeout > 1 || !unique)Â {
						var duplicateCount = 0;
						var testID = uuid4.generate();
						for (var i = datasets.loaded.length - 1; i >= 0; i--) {
							if (datasets.loaded[i].uuid == testID) {
								duplicateCount++;
								// check if others dataset values match
								var thesame = {};
								if (dataset == thesame){
									$log.info("Dataset already loaded.");
								} else {
									$log.warn("Not a unique ID");
								}
							}
						}
						if (duplicateCount === 0) {
							unique = true;
						}
						timeout--;
					}
					if (!unique && timeout === 0) {
						$log.warn("Timeout searching for unique UUID");
					}					
				}
				return dataset;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#add
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Adds dataset to Datasets from supplied data.
			 *
			 * @requires $log
			 *
			 * @param {Object} dataset Object.
			 * @returns {Object} Datasets Object.
			 */
			add: function(dataset) {
				var self = this;
				datasets.loaded.push(dataset);
				datasets.current.index = datasets.loaded.length - 1;
				$log.info("Dataset " + dataset.object.species + " " + dataset.object.region + " loaded from file.");
				return datasets;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#clear
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Clears Datasets Object.
			 *
			 * @returns {Object} Datasets Object.
			 */
			clear: function() {
				while (datasets.loaded.length > 0) {
					datasets.loaded.shift();
				}
				return $log.info("Datasets Object cleared!");
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#remove
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Removes dataset at supplied index from Datasets.
			 *
			 * @requires $log
			 *
			 * @param {number} [index] Index of dataset.
			 * @returns {Object} Datasets Object.
			 */
			remove: function(index) {
				if (index === undefined || index === false) index = datasets.current.index;
				var dataset = datasets.loaded.indexOf(index);
				var datasetTitle = dataset.title;
				datasets.loaded.splice(dataset, 1);
				$log.info("Dataset " + datasetTitle + "at index " + index + " removed!");
				return datasets;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#set
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Sets current dataset from those loaded in Datasets.
			 *
			 * @param {number} [index] Index of dataset.
			 * @returns {Object} Newly set current dataset.
			 */
			set: function(index) {
				var self = this;
				if (index !== undefined || index !== false) datasets.current.index = index;
				var dataset = datasets.loaded[datasets.current.index];
				return dataset;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#get
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Get Datasets.
			 *
			 * @returns {Object} Datasets.
			 */
			get: function() {
				return datasets;
			},

			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#getDataset			
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Get Datasets.
			 *
			 * @returns {Object} Datasets.
			 */
			getDataset: function(index) {
				if (index === undefined || index === false) index = datasets.current.index;
				var dataset = datasets.loaded[index];
				return dataset;
			},
			/**
			 * @ngdoc function
			 * @name TADkit.service:Datasets#getModel
			 * @methodOf TADkit.service:Datasets
			 * @kind function
			 *
			 * @description
			 * Get model from ref or current id no ref supplied. eg. { ref:1 , data:1,2,3 }
			 *
			 * @param {number} [ref] Model reference.
			 * @returns {Object} Model.
			 */
			getModel: function(ref) { // from model ref
				var self = this;
				ref = ref || 1;
				var model;
				for (var i = datasets.loaded[datasets.current.index].length - 1; i >= 0; i--) {
					if (datasets.loaded[datasets.current.index].models[i].ref == ref) model = datasets.loaded[datasets.current.index].models[i];
				}
				return model;
			},

		};
	}
})();
(function () {
	'use strict';
	/**
	 * @ngdoc overview
	 * @name layers
	 * @module layers
	 * @description
	 * Layers Module
	 * Contains layers scripts which are essential to the TADkit App.
	 *
	 * @example
	 * `angular.module('myApp',['takit.layers']);`
	 *
	 */
	angular
		.module('TADkit.layers', []);
}());
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:LayerAnnotations
	 * @description Layers to within a Project to be used in a Storyboard.
	 *  This Layer is equivalent to UCSC custom tack data file format which
	 * consists of Browser, Track and Data sections. See...
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 * @requires https://github.com/monicao/angular-uuid4
	 *
	 */
	angular
		.module('TADkit.layers')
		.factory('LayerAnnotations', LayerAnnotations);

	function LayerAnnotations($log, $q, $http, uuid4) {
		var annotations = {
			// browser requirements
			browser : {
				config : "default"
			},
			// visualization i.e. like UCSC 'tracks' but not just track specific
			viz : {
				defaultType : "track-bedgraph",
				source : "default",
				palette : ["#ff0000","#0000ff"],
				scale : 1
			},
			// data to be used (live on the fly - store last)
			data : {
				ref : "1",
				data : [""]
			}
		};

		return {
			build: function(data) {
				// var colorRange = ["#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff"];
				var colorFilion = ["#227c4f","#e71818","#8ece0d","#6666ff","#424242"];
				// Categorical Color Ragess e.g. d3.scale.category20()
				var colorRange = ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"];

				// columns to layers
				// skip row 1 = headers ie. length - 2
				// skip colums 1 and 2 = coords ie. length - 3
				var acquiredLayers = [];
				// check for bigwig data the step and start
				// var step = 1; // override below if fixed
				// if none find which is start and end eg. Marie's and Filion's data
				// cycle through first lineto determine columns
				// create as BedGraph
				var headerRow = 0;
				var firstDataRow = 1;
				var startColumn = 0;
				var endColumn = 1;
				var colsCount = data[headerRow].length;

				// Check if fixed steps
				var step = data[firstDataRow][endColumn] - data[firstDataRow][startColumn] + 1; // get step from chromEnd to chromStart
				var step2 = data[firstDataRow+1][endColumn] - data[firstDataRow+1][startColumn] + 1; // check next row
				var type, format, stepType;
				if (step == step2) {
					type = "wiggle_0";
					format = "fixed";
					stepType = "fixed";
				} else {
					type = "bedgraph";
					format = "variable";
					stepType = "variable";
				}

				// Check if Filion proteins ie. chromatin colors
				var filion = false;
				if (colsCount == 7){
					var filionProteins = 0;
					for (var h = 2; h < colsCount; h++) { // h=2 to skip start and end cols
						var header = data[headerRow][h].toLowerCase();
						if (header=="hp1" || header=="brm" || header=="mrg15" || header=="pc" || header=="h1") filionProteins++;
					}
					if (filionProteins == 5) filion = true;
				}

				for (var i = colsCount - 1; i >= 2; i--) { // i >= 2 to skip, start and end columns
					var colored;
					if (filion) {
						colored = colorFilion[i-2];
					} else {
						colored = colorRange[i];
					}				
					acquiredLayers.unshift(
						{
							"metadata": {
								"version" : 1.0,
								"type" : "layer",
								"generator" : "TADkit"
							},
							"object" : {
								"uuid" : uuid4.generate(),
								"id" : data[headerRow][i],
								"title" : data[headerRow][i],
								"source" : "Research output",
								"url" : "local",
								"description" : "center_label", //also BigWig description (track title): "User Supplied Track"
								"type" : type, //also BigWig type
								"format" : format,
								"components" : 2,
								"name" : data[headerRow][i], //BigWig: "User Track"
								"visibility" : "full", //BigWig: "full", "dense" or "hide"
								"color" : colored, // random from D3.js function. NOTE: convert to RGB for BigWig: eg. 255,255,255
								"altColor" : "#cccccc", // light grey gives best 3D render vis. NOTE: convert to RGB for BigWig: eg. 128,128,128
								"priority" : "100", //BigWig: 100
								"stepType" : stepType, //BigWig: "variable" or "fixed"
								"chrom" : "", //BigWig: derive from dataset...???
								"start" : data[firstDataRow][startColumn], //BigWig
								"step" : step, //BigWig
								"state" : {
									"index" : 0, // make real index???
									"overlaid" : false
								}
							},
							"palette" : [colored,"#cccccc"],
							"data" : [],
							"colors" : {
								"particles" : [],
								"chromatin" : [],
								"network" : {
									"RGB" : [],
									"alpha" : []
								}
							}
						}
					);
					// convert column data to array
					for (var j = data.length - 1; j >= 1; j--) { // j >= 1 to skip first header row
						if (format == "variable") {
							acquiredLayers[0].data.unshift({
								"start" : data[j][startColumn],
								"end" : data[j][endColumn],
								"read" : data[j][i]
							});
						} else {
							acquiredLayers[0].data.unshift(data[j][i]);
						}				
					}
				}
				return acquiredLayers;
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Annotations
	 * @description Tempalate for Layer to within TADkit
	 * This template structure is equivalent to UCSC custom
	 * track data file format of Browser, Track and Data.
	 *
	 */
	angular
		.module('TADkit.layers')
		.factory('LayerName', LayerName);

	function LayerName() {
		var layername = {
			// browser requirements
			browser : {
				config : "default"
			},
			// visualization i.e. like UCSC 'tracks' but not just track specific
			viz : {
				defaultType : "track-bigbed",
				source : "default",
				palette : ["#ff0000","#0000ff"],
				scale : 1
			},
			// data to be used (live on the fly - store last)
			data : {
				ref : "1",
				data : [""]
			}
		};

		return {
			build: function(data) {
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc service
	 * @name TADkit.service:Layers
	 * @description Layers of Projects.
	 *
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$log
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$q
	 * @requires https://code.angularjs.org/1.3.16/docs/api/ng/service/$http
	 * @requires https://github.com/monicao/angular-uuid4
	 * @requires TADkit.service:Settings
	 * @requires TADkit.service:Storyboards
	 * @requires TADkit.service:FeaturesEnsembl
	 * @requires TADkit.service:EnsemblColors
	 * @requires TADkit.service:Segments
	 * @requires TADkit.service:Networks
	 *
	 */
	angular
		.module('TADkit.layers')
		.factory('Layers', Layers);

	function Layers(VERBOSE, $log, $q, $http, uuid4, Settings, Storyboards, FeaturesEnsembl, EnsemblColors, Segments, Networks) {
		var layers = {
			loaded : [],
			current : {
				index: 0
			}
		};

		return {
			// Layers already parsed and filtered, stored as JSON
			load: function() {
				var deferred = $q.defer();
				var dataUrl = "assets/defaults/tk-defaults-layers.json";
				if( layers.loaded.length > 0 ) {
					 deferred.resolve(layers);
				} else {
					$http.get(dataUrl)
					.success( function(data) {
						layers.loaded = data;
						// layers.current.index = layers.loaded.length - 1;
						$log.debug("Layers (" + data.length + ") loaded from " + dataUrl);
						deferred.resolve(layers);
					});
				}
				return deferred.promise;
			},
			// Â¿Â¿Â¿ IS THIS FUNCTION REQUIRED ???
			// Preload or generate TSV example?
			// loadFromFile: function(filename, filetype, defaults) {
			// 	filename = filename || "tk-example-dataset";
			// 	filetype = filetype || "tsv";
			// 	if (typeof defaults === 'undefined') defaults = true;
			// 	var self = this;

			// 	var deferred = $q.defer();
			// 	var datapath = "examples";
			// 	var dataUrl = "assets/" + datapath + "/" + filename + "." + filetype;
			// 	$http.get(dataUrl)
			// 	.success( function(fileData) {
			// 		self.import(fileData,[],[]);
			// 		$log.debug("Layers (" + fileData.length + ") imported from " + dataUrl);
			// 		deferred.resolve(fileData);
			// 	})
			// 	.error(function(fileData) {
			// 		$log.error("No associated data found.");
			// 	});
			// 	return deferred.promise;
			// },
			import: function(dataset) {
				var self = this;

				var data = dataset.data;
				// var colorRange = ["#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff","#ff0000","#00ff00","#0000ff"];
				var colorFilion = ["#227c4f","#e71818","#8ece0d","#6666ff","#424242"];
				// Categorical Color Ragess e.g. d3.scale.category20()
				var colorRange = ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"];

				// columns to layers
				// skip row 1 = headers ie. length - 2
				// skip colums 1 and 2 = coords ie. length - 3
				var acquiredLayers = [];
				// check for bigwig data the step and start
				// var step = 1; // override below if fixed
				// if none find which is start and end eg. Marie's and Filion's data
				// cycle through first lineto determine columns
				// create as BedGraph
				var headerRow = 0;
				var firstDataRow = 1;
				var startColumn = 0;
				var endColumn = 1;
				var colsCount = data[headerRow].length;

				// Check if fixed steps
				var step = data[firstDataRow][endColumn] - data[firstDataRow][startColumn] + 1; // get step from chromEnd to chromStart
				var step2 = data[firstDataRow+1][endColumn] - data[firstDataRow+1][startColumn] + 1; // check next row
				var type, format, stepType;
				if (step == step2) {
					type = "wiggle_0";
					format = "fixed";
					stepType = "fixed";
				} else {
					type = "bedgraph";
					format = "variable";
					stepType = "variable";
				}

				// Check if Filion proteins ie. chromatin colors
				var filion = false;
				if (colsCount == 7){
					var filionProteins = 0;
					for (var h = 2; h < colsCount; h++) { // h=2 to skip start and end cols
						var header = data[headerRow][h].toLowerCase();
						if (header=="hp1" || header=="brm" || header=="mrg15" || header=="pc" || header=="h1") filionProteins++;
					}
					if (filionProteins == 5) filion = true;
				}

				for (var i = colsCount - 1; i >= 2; i--) { // i >= 2 to skip, start and end columns
					var colored;
					if (filion) {
						colored = colorFilion[i-2];
					} else {
						colored = colorRange[i];
					}				
					acquiredLayers.unshift(
						{
							"metadata": {
								"version" : 1.0,
								"type" : "layer",
								"generator" : "TADkit"
							},
							"object" : {
								"uuid" : uuid4.generate(),
								"id" : data[headerRow][i],
								"title" : data[headerRow][i],
								"source" : "Research output",
								"url" : "local",
								"description" : "center_label", //also BigWig description (track title): "User Supplied Track"
								"type" : type, //also BigWig type
								"format" : format,
								"components" : 2,
								"name" : data[headerRow][i], //BigWig: "User Track"
								"visibility" : "full", //BigWig: "full", "dense" or "hide"
								"color" : colored, // random from D3.js function. NOTE: convert to RGB for BigWig: eg. 255,255,255
								"altColor" : "#cccccc", // light grey gives best 3D render vis. NOTE: convert to RGB for BigWig: eg. 128,128,128
								"priority" : "100", //BigWig: 100
								"stepType" : stepType, //BigWig: "variable" or "fixed"
								"chrom" : "", //BigWig: derive from dataset...???
								"start" : data[firstDataRow][startColumn], //BigWig
								"step" : step, //BigWig
								"state" : {
									"index" : 0, // make real index???
									"overlaid" : false
								}
							},
							"palette" : [colored,"#cccccc"],
							"data" : [],
							"colors" : {
								"particles" : [],
								"chromatin" : [],
								"network" : {
									"RGB" : [],
									"alpha" : []
								}
							}
						}
					);
					// convert column data to array
					for (var j = data.length - 1; j >= 1; j--) { // j >= 1 to skip first header row
						if (format == "variable") {
							acquiredLayers[0].data.unshift({
								"start" : data[j][startColumn],
								"end" : data[j][endColumn],
								"read" : data[j][i]
							});
						} else {
							acquiredLayers[0].data.unshift(data[j][i]);
						}				
					}
				}
				console.log(acquiredLayers);
				self.add(acquiredLayers);
				return acquiredLayers;
			},
			add: function(importedLayers) {
				var self = this;
				// convert to function in Layers service
				var newLayers = [];
				var currentLayersIndex = layers.loaded.length - 1;
				angular.forEach(importedLayers, function(layer, key) {
					var layerExists = false;
					// for (var i = layers.loaded.length - 1; i >= 0; i--) {
					// 	$log.debug(layers.loaded[i].object.uuid);
					// 	$log.debug(layer.object.uuid);
					// 	// if (layers.loaded[i].object.uuid == layer.object.uuid) layerExists = true;
					// }
					if (!layerExists) {
						currentLayersIndex++;
						layer.object.state.index = currentLayersIndex;
						layer.object.state.overlaid = false;
						newLayers.push(layer);
						Storyboards.addComponent(layer);
					}
				});
				// Add newLayers to Layers
				layers.loaded = layers.loaded.concat(newLayers);
				// Generate colors arrays for new layers
				self.segment();

				return newLayers;
			},
			clear: function() {
				while (layers.loaded.length > 0) { // remove all layers
					layers.loaded.shift();
				}
			},
			defaults: function() {
				while (layers.loaded.length > 4) { // remove all except defaults
					layers.loaded.pop();
					// remove associated components
					Storyboards.defaultComponents();
				}
			},
			remove: function(index) {
				if (index === undefined || index === false) index = layers.current.index;
				var layer = layers.loaded.indexOf(index);
				layers.loaded.splice(layer, 1);
				return layers;
			},
			set: function(index) {
				if (index !== undefined || index !== false) layers.current.index = index;
				var current = layers.loaded[layers.current.index];
				return current;
			},
			setOverlaid: function (index) {
				index = index || "";
				angular.forEach(layers.loaded, function(layer) {
					if (layer.object.state.index === index) {
						layer.object.state.overlaid = true;
					} else {
						layer.object.state.overlaid = false;
					}
				});
				return index;
			},
			update: function(distances, restraints) {
				// things that need updating for changes:
				// - ext.data eg. Features
				// - proximities (derived from datsets)
				// - segments (derived from datsets)
				var self = this;
				var layersAsync = []; // push async functions into list for subsequent processing
				var layersToUpdate = [];
				angular.forEach(layers.loaded, function(layer, key) {

					// For Layers with Aync Features Data eg. genes
					// ADD check if changed...
					if (layer.object.type == "ensembl") { // more generic than id == "genes"
						var address = Settings.getAddress();
						var features = FeaturesEnsembl.load(layer, address);
						layersAsync.push(features);
						layersToUpdate.push(layer);
					}

					// // UNUSED???
					// if (layer.object.id == "proximities") {
					// 	layer.data = distances;
					// }

					// // UNUSED???
					// if (layer.object.id == "restraints") {
					// 	layer.data = restraints;
					// }

				});
				return $q.all(layersAsync)
				.then(function(results) {
					for (var i = 0; i < layersToUpdate.length; i++) {
						var layer = layersToUpdate[i];
						Storyboards.update(layer);
					}
					self.segment();
					return results;
				});

			},
			segment: function() {
				var self = this; // SYNChronous functions...
				// Segments.load().then(function() {
					var settings = Settings.get();
					angular.forEach(layers.loaded, function(layer, key) {
						// check if colors already exist (for chromatin as principal set) or number of segments have changed
						var segmented = true;
						if (segmented) {
						// if (!layer.colors.chromatin || layer.colors.chromatin.length === 0) { // ??? || (layer.colors.chromatin && segmentsCount != settings.segmentsCount)
							// run function based on object type
							var type = layer.object.type;
							var format = layer.object.format;
							if (type == "gradient" && format == "hex") {
								// palette must contain 2 hex values
								layer.colors.particles = Segments.gradientHCL(layer, settings.current.particlesCount);
								layer.colors.chromatin = Segments.gradientHCL(layer, settings.current.segmentsCount);
								layer.colors.network.RGB = Networks.lineSegmentsRGB(layer, settings.current.edgesCount);
								layer.colors.network.alpha = Networks.lineSegmentsAlpha(layer, settings.current.edgesCount);
							} else if (type == "wiggle_0" && format == "fixed") {
								// OJO! create additional option for format = "bigwig-variable"
								layer.colors.particles = Segments.bicolor(layer, settings.current.particlesCount);
								layer.colors.chromatin = Segments.bicolor(layer, settings.current.segmentsCount);
								layer.colors.network.RGB = Networks.lineSegmentsRGB(layer, settings.current.edgesCount);
								layer.colors.network.alpha = Networks.lineSegmentsAlpha(layer, settings.current.edgesCount);
							} else if (type == "wiggle_0" && format == "variable") {
								// To Do...
							} else if (type == "bedgraph") {
								layer.colors.particles = Segments.bicolorVariable(layer, settings.current.chromStart, settings.current.particlesCount, 1);
								layer.colors.chromatin = Segments.bicolorVariable(layer, settings.current.chromStart, settings.current.segmentsCount, settings.current.segmentLength);
								layer.colors.network.RGB = Networks.lineSegmentsRGB(layer, settings.current.edgesCount);
								layer.colors.network.alpha = Networks.lineSegmentsAlpha(layer, settings.current.edgesCount);
							} else if (type == "matrix") {
								// Distances are per edge so just convert to color
								layer.colors.particlesMatrix = Segments.matrix(layer, 1); // ie. per particle
								layer.colors.chromatinMatrix = Segments.matrix(layer, settings.current.particleSegments);
								layer.colors.networkMatrix = layer.colors.particlesMatrix; // ie. also color network edges by matrix
								self.at(1, settings.current.particlesCount, settings.current.particleSegments);
							} else if (type == "misc" && format == "variable") { // eg. restraints
								layer.colors.particles = [];
								layer.colors.chromatin = [];
								layer.colors.network.RGB = Networks.lineSegmentsRGB(layer, settings.current.edgesCount);
								layer.colors.network.alpha = Networks.lineSegmentsAlpha(layer, settings.current.edgesCount);
							} else if (type == "ensembl" && format == "json") {
								// data must have .start and .end
								var features = EnsemblColors.get("gene");
								var singleSegment = 1;
								layer.colors.particles = Segments.features(layer, settings.current.chromStart, settings.current.particlesCount, singleSegment, features);
								layer.colors.chromatin = Segments.features(layer, settings.current.chromStart, settings.current.segmentsCount, settings.current.segmentLength, features);
								layer.colors.network.RGB = Networks.lineSegmentsRGB(layer, settings.current.edgesCount);
								layer.colors.network.alpha = Networks.lineSegmentsAlpha(layer, settings.current.edgesCount);
							}
						} else {
							// already segmented
							$log.warn("Layer '" + layer.object.title + "' already segmented as color array matching current dataset length");
						}

					});
					return layers;
				// });
			},
			at: function(currentParticle) {
				var settings = Settings.get();
				angular.forEach(layers.loaded, function(layer, key) {
					var type = layer.object.type;
					if (type == "matrix") {
						var particleStart = (currentParticle - 1) * settings.current.particlesCount;
						var particleEnd = currentParticle * settings.current.particlesCount;
						var chromatinStart = particleStart * settings.current.particleSegments;
						var chromatinEnd = particleEnd * settings.current.particleSegments;

						layer.colors.particles = layer.colors.particlesMatrix.slice(particleStart, particleEnd);
						layer.colors.chromatin = layer.colors.chromatinMatrix.slice(chromatinStart, chromatinEnd);
						layer.colors.network = layer.colors.networkMatrix.slice(particleStart, particleEnd);
					}
				});
				return layers;
			},
			get: function() {
				return layers;
			},
			getLayer: function(index) {
				if (index === undefined || index === false) index = layers.current.index;
				var layer = layers.loaded[index];
				return layer;
			},
			getLayerById: function (id) {
				var layer, found;
				if (id !== undefined || id !== false) {
					for (var i = layers.loaded.length - 1; i >= 0; i--) {
						if (layers.loaded[i].object.id === id) {
							layer = layers.loaded[i];
							layer.object.state.index = i;
							found = true;
							$log.debug("Layer \"" + id + "\" found!");
						}
					}
				}
				if (!found) {
					layer = layers.loaded[layers.current.index];
					layer.object.state.index = layers.current.index;
					$log.debug("Layer \"" + id + "\" not found: returning current.");
				}
				if (VERBOSE) $log.debug(layer);
				return layer;
			},
			getCurrentIndex: function() {
				return layers.current.index;
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkComponent
	 * @restrict EA
	 *
	 * @description
	 * Dummy components directive that is replaced on complie
	 * by real component directive from supplied object type.
	 * e.g. from a array of components objects
	 *
	 * @example
	 * `<div tk-component ng-repeat='component in components'></div>`
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkComponent', tkComponent);

	function tkComponent(VERBOSE, $log, $compile) {
		return {
			restrict: 'EA',
			// controller: 'StoryboardController',
			link: function(scope, element, attrs) {
				if (VERBOSE) $log.debug(scope);
				
				scope.component.object.idIndex = scope.component.object.id + "-" + scope.$index;

				var strTemplate = '<data-tk-component-' + scope.component.object.type + ' ' +
					'id="{{component.object.idIndex}}" ' +
					'type="component.object.type" ' +
					'title="{{component.object.title}}" ' +
					'state="component.object.state" ' + /* for scene until can check for DOM loaded */
					'settings="settings" ' +
					'view="component.view" ' +
					'currentparticle="currentParticle"' +
					'currentposition="currentPosition"' +
					'currentmodel="current.model" ' +
					'currentlayer="current.layer" ' +
					'data="component.data" ' +
					'proximities="component.proximities" ' +
					'layer="component.layer"' +
					'togglelayer="toggleLayer(index)" ' +
					'style="margin: {{component.object.state.margin}}; background-color: {{component.view.settings.background}}" ' +
					'class="component ' + scope.component.object.type + '">' +
					'</data-tk-component-' + scope.component.object.type + '>';

				element.replaceWith($compile(strTemplate)(scope));
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkComponentBrowserBiodalliance
	 * @restrict EA
	 *
	 * @description
	 * Biodalliance browser directive that is replaced on complie
	 * by real component directive from supplied object type.
	 * e.g. from a array of components objects
	 *
	 * @example
	 * `<div tk-component-track-biodalliance ng-repeat='component in components'></div>`
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkComponentBrowserBiodalliance', tkComponentBrowserBiodalliance);

	function tkComponentBrowserBiodalliance(VERBOSE, $log) {
		return {
			restrict: 'E',
			templateUrl: 'assets/templates/browser.html',
			link: function(scope, element, attrs) {
				console.log(scope.component.view.viewpoint.chromStart);

				var browser = new Browser({
					pageName: element[0].firstChild.id, // Target element ID.

					chr: '1',
					viewStart: scope.component.view.viewpoint.chromStart,
					viewEnd: scope.component.view.viewpoint.chromEnd,
					cookieKey: 'human',

					coordSystem: {
						speciesName: 'Human',
						taxon: 9606,
						auth: 'NCBI',
						version: '36',
						ucscName: 'hg18'
					},

					

					sources: [{
						name: 'Genome',
						uri: 'http://www.derkholm.net:8080/das/hg18comp/',
						tier_type: 'sequence',
						provides_entrypoints: true
					}, {
						name: 'Genes',
						desc: 'Gene structures from Ensembl 54',
						uri: 'http://www.derkholm.net:8080/das/hsa_54_36p/',
						collapseSuperGroups: true,
						provides_karyotype: true,
						provides_search: true
					}, {
						name: 'Repeats',
						uri: 'http://www.derkholm.net:8080/das/hsa_54_36p/',
						stylesheet_uri: 'http://www.derkholm.net/dalliance-test/stylesheets/ens-repeats.xml'
					}, {
						name: 'MeDIP raw',
						uri: 'http://www.derkholm.net:8080/das/medipseq_reads'
					}, {
						name: 'MeDIP-seq',
						uri: 'http://www.ebi.ac.uk/das-srv/genomicdas/das/batman_seq_SP/'
					}]
				});
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkComponentBrowserGenoverse
	 * @restrict EA
	 *
	 * @description
	 * Genoverse browser directive that is replaced on complie
	 * by real component directive from supplied object type.
	 * e.g. from a array of components objects
	 *
	 * @example
	 * `<div tk-component-track-biodalliance ng-repeat='component in components'></div>`
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkComponentBrowserGenoverse', tkComponentBrowserGenoverse);

	function tkComponentBrowserGenoverse(VERBOSE, $log, GenoverseService) {
		return {
			restrict: 'E',
			templateUrl: 'assets/templates/browser.html',
			link: function(scope, element, attrs) {
				var config = "{container:'#" + scope.component.object.idIndex + "'";
				config += ",genome:'grch38'";
				config += ",chr:1";// + scope.component.view.viewpoint.chrom;
				config += ",start:" + scope.component.view.viewpoint.chromStart;
				config += ",end:" + scope.component.view.viewpoint.chromEnd;
				config += ",plugins:['fileDrop']";
				config += ",tracks:[";
					config += "Genoverse.Track.Scalebar,";
					config += "Genoverse.Track.extend({name:'Sequence',controller:Genoverse.Track.Controller.Sequence,model:Genoverse.Track.Model.Sequence.Ensembl,view:Genoverse.Track.View.Sequence,100000:false,resizable:'auto'}),";
					config += "Genoverse.Track.Gene,";
					config += "Genoverse.Track.extend({name:'RegulatoryFeatures',url:'http://rest.ensembl.org/overlap/region/human/__CHR__:__START__-__END__?feature=regulatory;content-type=application/json',resizable:'auto',model:Genoverse.Track.Model.extend({dataRequestLimit:5000000}),setFeatureColor:function(f){f.color='#AAA';}}),";
					config += "Genoverse.Track.dbSNP";
					config += "]}";

				GenoverseService.load(config).then(function(Genoverse) {
					$log.debug(window.Genoverse);
				});		
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkComponentBrowserJsorolla
	 * @restrict EA
	 *
	 * @description
	 * OpenCB/jsorolla/	genome-viewer directive that is replaced on complie
	 * by real component directive from supplied object type.
	 * e.g. from a array of components objects
	 *
	 * @example
	 * `<div tk-component-track-browser-jsorolla ng-repeat='component in components'></div>`
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkComponentBrowserJsorolla', tkComponentBrowserJsorolla);

	function tkComponentBrowserJsorolla(VERBOSE, $log, JsorollaService) {
		return {
			restrict: 'E',
			templateUrl: 'assets/templates/browser.html',
			link: function(scope, element, attrs) {

				// var target =  element[0].firstElementChild.id;
				var target = scope.component.object.idIndex + "-holder";

				var componentMargin = parseInt(scope.component.view.settings.margin);
				var margin = {
						top: parseInt(scope.component.view.settings.padding.top),
						right: parseInt(scope.component.view.settings.padding.right),
						bottom: parseInt(scope.component.view.settings.padding.bottom),
						left: parseInt(scope.component.view.settings.padding.left)
					},
					scale = 4,
					trackHeight = parseInt(scope.component.view.settings.heightInner),
					nodeHeight = trackHeight * 0.5,
					verticalOffset = (trackHeight - nodeHeight) * 0.5,
					nodePadding = 0,
					nodeColor = scope.component.view.settings.color;

				var component = element[0].parentNode;
				var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
					height = trackHeight - margin.top - margin.bottom;

				var genomeViewer = null;
				
				function speciesCB2JS() {
					// convert Cellbase SPECIES to Jsorola SPECIES...
					var species = { "text": "Species", "items": [] };
					angular.forEach(SPECIES, function(kingdom, index) {
						var newKingdom = {"text": index, "items": kingdom };
						species.items.push(newKingdom);
					});
					return species;
				}

				JsorollaService.load().then(function() {
					var kingdom = "metazoa";
					var species = {};
					var availibleSpecies = speciesCB2JS();
					var speciesName = scope.component.view.viewpoint.species.toLowerCase();
					for (var i = availibleSpecies.items.length - 1; i >= 0; i--) {
						var kingdomSpecies = availibleSpecies.items[i].items;
						for (var j = kingdomSpecies.length - 1; j >= 0; j--) {
							var speciesTest = kingdomSpecies[j];
							var lowerName = speciesTest.scientificName.toLowerCase();
							if (lowerName == speciesName) {
								species = speciesTest;
								$log.info( "Cellbase: Found species: " + lowerName + " (id: " + speciesTest.id + ")" );
							}
						}
					}

					if (!species) {
						species = availibleSpecies.metazoa.items[1]; // second in list of Metazoa == Drosophila Melanogaster
						$log.warn( "Cellbase: Species not found! Returning: " + species.scientificName );
					}

					var region = new Region({
						chromosome: scope.component.view.viewpoint.chrom,
						start: scope.component.view.viewpoint.chromStart,
						end: scope.component.view.viewpoint.chromEnd
					});

					var CELLBASE_HOST = 'https://wwwdev.ebi.ac.uk/cellbase/webservices/rest';

					genomeViewer = new GenomeViewer({
						cellBaseHost: CELLBASE_HOST,
						cellBaseVersion: 'v3',
						target: target,
						width: width,
						region: region,
						availableSpecies: availibleSpecies,
						species: species.id,
						sidePanel: false,
						autoRender: true,
						resizable: true,
				//        quickSearchResultFn:quickSearchResultFn,
				//        quickSearchDisplayKey:,
						karyotypePanelConfig: {
							collapsed: false,
							collapsible: true
						},
						chromosomePanelConfig: {
							collapsed: false,
							collapsible: true
						},
						navigationBarConfig: {
							componentsConfig: {
				//                restoreDefaultRegionButton:false,
				//                regionHistoryButton:false,
				//                speciesButton:false,
				//                chromosomesButton:false,
				//                karyotypeButton:false,
				//                chromosomeButton:false,
				//                regionButton:false,
				//                zoomControl:false,
				//                windowSizeControl:false,
				//                positionControl:false,
				//                moveControl:false,
				//                autoheightButton:false,
				//                compactButton:false,
				//                searchControl:false
							}
						},
						handlers: {
							'region:change': function (e) {
								console.log(e);
							}
						}
				//        chromosomeList:[]
				//            trackListTitle: ''
				//            drawNavigationBar = true;
				//            drawKaryotypePanel: false,
				//            drawChromosomePanel: false,
				//            drawOverviewTrackListPanel: false

					});

					$log.debug(genomeViewer);
					$log.info("Browser directive loaded");
				});		
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkComponentBrowserJsorolla
	 * @restrict EA
	 *
	 * @description
	 * OpenCB/jsorolla/	genome-viewer directive that is replaced on complie
	 * by real component directive from supplied object type.
	 * e.g. from a array of components objects
	 *
	 * @example
	 * `<div tk-component-track-browser-jsorolla ng-repeat='component in components'></div>`
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkComponentBrowserJsorolla', tkComponentBrowserJsorolla);

	function tkComponentBrowserJsorolla(VERBOSE, $log, JsorollaService) {
		return {
			restrict: 'E',
			templateUrl: 'assets/templates/browser.html',
			link: function(scope, element, attrs) {

				// var target =  element[0].firstElementChild.id;
				var target = scope.component.object.idIndex + "-holder";

				var componentMargin = parseInt(scope.component.view.settings.margin);
				var margin = {
						top: parseInt(scope.component.view.settings.padding.top),
						right: parseInt(scope.component.view.settings.padding.right),
						bottom: parseInt(scope.component.view.settings.padding.bottom),
						left: parseInt(scope.component.view.settings.padding.left)
					},
					scale = 4,
					trackHeight = parseInt(scope.component.view.settings.heightInner),
					nodeHeight = trackHeight * 0.5,
					verticalOffset = (trackHeight - nodeHeight) * 0.5,
					nodePadding = 0,
					nodeColor = scope.component.view.settings.color;

				var component = element[0].parentNode;
				var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
					height = trackHeight - margin.top - margin.bottom;

				var speciesName = scope.component.view.viewpoint.species.toLowerCase();
				var chromosome = scope.component.view.viewpoint.chrom;
				var chromStart = scope.component.view.viewpoint.chromStart;
				var chromEnd = scope.component.view.viewpoint.chromEnd;

				JsorollaService.load().then(function() {
					var genomeViewer;

					var AVAILABLE_SPECIES;
					// var CELLBASE_HOST = 'https://wwwdev.ebi.ac.uk/cellbase';
					// var CELLBASE_HOST = 'https://www.ebi.ac.uk/cellbase';
					var CELLBASE_HOST = "http://bioinfodev.hpc.cam.ac.uk/cellbase";
					// var CELLBASE_HOST = "http://bioinfo.hpc.cam.ac.uk/cellbase";

					var CELLBASE_VERSION = "v3";

					var region = new Region({ chromosome: chromosome, start: chromStart, end: chromEnd });

					getSpecies(function(s) {
						AVAILABLE_SPECIES = s;
						run();
					});

					function getSpecies(callback) {
						CellBaseManager.get({
							host: CELLBASE_HOST,
							category: "meta",
							subCategory: "species",
							success: function(r) {
								var taxonomies = r.response[0].result[0];
								for (var taxonomy in taxonomies) {
									var newSpecies = [];
									for (var i = 0; i < taxonomies[taxonomy].length; i++) {
										var species = taxonomies[taxonomy][i];
										for (var j = 0; j < species.assemblies.length; j++) {
											var s = Utils.clone(species);
											s.assembly = species.assemblies[j];
											delete s.assemblies;
											newSpecies.push(s);
										}
									}
									taxonomies[taxonomy] = newSpecies;
								}
								callback(taxonomies);
							}
						});
					}

					function run() {
						var species;
						for (var kingdom in AVAILABLE_SPECIES) {
							var kingdomSpecies = AVAILABLE_SPECIES[kingdom];
							for (var j = kingdomSpecies.length - 1; j >= 0; j--) {
								var speciesTest = kingdomSpecies[j];
								if (speciesTest.scientificName.toLowerCase() == speciesName) {
									species = speciesTest;
									$log.info( "Cellbase: Found species: " + speciesTest.scientificName + " (id: " + speciesTest.id + ")" );
								}
							}
						}
						if (!species) {
							species = AVAILABLE_SPECIES.metazoa.items[1]; // second in list of Metazoa == Drosophila Melanogaster
							$log.warn( "Cellbase: Species not found! Returning: " + species.scientificName );
						}

						genomeViewer = new GenomeViewer({
							cellBaseHost : CELLBASE_HOST,
							cellBaseVersion : CELLBASE_VERSION,
							target : target,
							width : width + 18, // for hardocded scroll margin in genome-viewer.js line 25527
							region : region,
							availableSpecies : AVAILABLE_SPECIES,
							species : species,
							sidePanel : false,
							autoRender : true,
							resizable : true,
							// quickSearchResultFn : quickSearchResultFn,
							// quickSearchDisplayKey: false,
							karyotypePanelConfig: {
								collapsed : false,
								collapsible : false
							},
							chromosomePanelConfig : {
								collapsed : false,
								collapsible : false
							},
							navigationBarConfig : {
								componentsConfig : {
								// restoreDefaultRegionButton : false,
								// regionHistoryButton : false,
								// speciesButton : false,
								// chromosomesButton : false,
								// karyotypeButton : false,
								// chromosomeButton : false,
								// regionButton : false,
								// zoomControl : false,
								// windowSizeControl : false,
								// positionControl : false,
								// moveControl : false,
								// autoheightButton : false,
								// compactButton : false,
								// searchControl : false
								}
							},
							handlers : {
								'region:change' : function (e) {
									// console.log(e);
								}
							},
							// chromosomeList : [],
							trackListTitle : "",
							drawNavigationBar : false,
							drawKaryotypePanel : false,
							drawChromosomePanel : false,
							drawOverviewTrackListPanel : false
						});

						var tracks = [];

						// var sequence = new FeatureTrack({
						// 	title: 'Sequence',
						// 	height: 25,
						// 	visibleRegionSize: 200,

						// 	renderer: new SequenceRenderer(),
						// 	dataAdapter: new CellBaseAdapter({
						// 		category: "genomic",
						// 		subCategory: "region",
						// 		resource: "sequence",
						// 		params: {},
						// 		species: genomeViewer.species,
						// 		cacheConfig: {
						// 			chunkSize: 100
						// 		}
						// 	})
						// });
						// tracks.push(sequence);

						var gene = new GeneTrack({
							title : undefined,
							minHistogramRegionSize : 20000000,
							maxLabelRegionSize : 10000000,
							minTranscriptRegionSize : 200000,
							height : 100,

							renderer: new GeneRenderer({
								handlers: {
									'feature:click' : function(event) {
										// console.log("Gene track clicked");
										// console.log(event);
									}
								}
							}),

							dataAdapter : new CellBaseAdapter({
								category : "genomic",
								subCategory : "region",
								resource : "gene",
								species : genomeViewer.species,
								params : {
									exclude : 'transcripts'
									// exclude : "transcripts.tfbs,transcripts.xrefs,transcripts.exons.sequence"
								},
								cacheConfig : {
									chunkSize : 100000
								}
							})
						});
						tracks.push(gene);

						// var renderer = new FeatureRenderer(FEATURE_TYPES.gene);
						// renderer.on({
						// 	'feature:click': function(event) {
						// 		// feature click event example
						// 		console.log(event)
						// 	}
						// });
						// var geneOverview = new FeatureTrack({
						// 	title: 'Gene overview',
						// 	minHistogramRegionSize: 20000000,
						// 	maxLabelRegionSize: 10000000,
						// 	height: 100,

						// 	renderer: renderer,

						// 	dataAdapter: new CellBaseAdapter({
						// 		category: "genomic",
						// 		subCategory: "region",
						// 		resource: "gene",
						// 		params: {
						// 			exclude: 'transcripts,chunkIds'
						// 		},
						// 		species: genomeViewer.species,
						// 		cacheConfig: {
						// 			chunkSize: 100000
						// 		}
						// 	})
						// });
						// genomeViewer.addOverviewTrack(geneOverview);

						// var snp = new FeatureTrack({
						// 	title: 'SNP',
						// 	featureType: 'SNP',
						// 	minHistogramRegionSize: 12000,
						// 	maxLabelRegionSize: 3000,
						// 	height: 120,
						// 	renderer: new FeatureRenderer(FEATURE_TYPES.snp),
						// 	dataAdapter: new CellBaseAdapter({
						// 		category: "genomic",
						// 		subCategory: "region",
						// 		resource: "snp",
						// 		params: {
						// 			exclude: 'transcriptVariations,xrefs,samples'
						// 		},
						// 		species: genomeViewer.species,
						// 		cacheConfig: {
						// 			chunkSize: 10000
						// 		}
						// 	})
						// });
						// tracks.push(snp);

						// var customTrack = new FeatureTrack({
						// 	title: 'custom track',
						// 	minHistogramRegionSize: 12000,
						// 	maxLabelRegionSize: 3000,
						// 	height: 120,

						// 	renderer: new FeatureRenderer(),

						// 	dataAdapter: new FeatureTemplateAdapter({
						// 	  multiRegions: true,
						// 	  histogramMultiRegions: false,
						// 	  uriTemplate: 'https://dcc.icgc.org/api/browser/gene?segment={region}&resource=gene',
						// 	  cacheConfig: {
						// 		chunkSize: 100000
						// 	  }
						// 	})
						// });
						// tracks.push(customTrack);

						genomeViewer.addTrack(tracks);
						genomeViewer.draw();

						$log.debug(genomeViewer);
						$log.info("Browser directive loaded");
					}
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('BrowserController', BrowserController);

	function BrowserController($log, $scope) {
		// console.log($scope);
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('PanelInfoboxController', PanelInfoboxController);

	function PanelInfoboxController($scope) {
		$scope.species = $scope.current.dataset.object.species;
		$scope.region = $scope.current.dataset.object.region;
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentPanelInfobox', tkComponentPanelInfobox);

	function tkComponentPanelInfobox() {
		return {
			restrict:'C',
			templateUrl: 'assets/templates/panel-infobox.html',
			link:function(scope, element, attrs){
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('PanelInspectorController', PanelInspectorController);

	function PanelInspectorController($scope, $mdDialog) {

		$scope.optionsState = false;
		$scope.toggleOptions = function() {
			$scope.optionsState = !$scope.optionsState;
		};

		$scope.toggle = function(bool) {
			bool = !bool;
		};

		$scope.width = parseInt($scope.state.width); // strip PX units
		$scope.height = parseInt($scope.state.height); // strip PX units

		$scope.atPosition = function(gene) {
			if ($scope.$parent.settings.current.segmentUpper >= gene.start && $scope.$parent.settings.current.segmentLower <= gene.end) return true;
			return false;
		};

		$scope.formatRegionName = function(regionName) {
			if (regionName == "Chromosome") {
				return regionName;
			} else {
				return "chr" + regionName;
			}
		};
		
		$scope.featureTitle = function(feature) {
			if (!feature.external_name) {
				return feature.id;
			} else {
				return feature.external_name;
			}
		};


		$scope.getDetails = function(item, event) {
			$mdDialog.show(
				$mdDialog.alert()
					.title('Details')
					.content(item.description)
					.ariaLabel('Item details')
					.ok('Close')
					.targetEvent(event)
			);
		};
	}

})();
	(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentPanelInspector', tkComponentPanelInspector);

	function tkComponentPanelInspector(VERBOSE, $log) {
		return {
			restrict: 'EA',
			scope: { 
				id: '@',
				state: '=',
				view: '=',
				data: '=',
				settings:'='
			},
			templateUrl: 'assets/templates/panel-inspector.html',
			link:function(scope, element, attrs){
				if (VERBOSE) $log.debug(scope.data);
			}
		};
	}
})();
 (function() {
	'use strict';
	angular
		.module('TADkit')
		.factory('Chromatin', Chromatin);

	// constructor for chromatin model instances
	function Chromatin(VERBOSE, $log, Paths, PathControls) {
		return function(data, colors, settings) {
			if (VERBOSE) $log.debug(colors);

			var defaults = {
				visible: true,
				genomeLength: 816394, // bactieria mycoplasma_pneumoniae_m129
				particles: 0,
				particleSegments: 5,
				curveSegments: 1,
				radius: 15,
				radiusSegments: 16,
				endcap: false,
				pathClosed: false
			};		
			settings = settings || {};
			angular.extend(this, angular.copy(defaults), settings);

			// Convert Data to Vector triplets
			var geometry = getGeometry(data);
			for (var g = geometry.vertices.length - 1; g >= 0; g--) {
				var geometryColor = new THREE.Color(colors[g*20]);
				geometry.colors.unshift(geometryColor);
			}

			// Derive path controls from geometry vectors
			// var pathControls = getPathControls( geometry.vertices );
			var pathControls = PathControls.cubic(geometry.vertices, this.pathClosed);

			var controlsGeom = new THREE.Geometry();
			for ( var h = 0; h < pathControls.vertices.length; h ++ ) {
				controlsGeom.vertices.push( new THREE.Vector3( pathControls.vertices[h].x, pathControls.vertices[h].y, pathControls.vertices[h].z || 0) );
				var vertexColor = pathControls.colors[h];
				controlsGeom.colors.push(vertexColor);
			}
			controlsGeom.name = "controlsGeom";

			// Set number of Particles
			if (this.particles === 0) this.particles = geometry.vertices.length; //pathControls.vertices.length - 1;
			// Derive chromatin geometry path segments
			var pathSegments = this.particles * this.particleSegments; // same as segmentsCount...
			this.pathSegments = pathSegments;

			/*** TODO: Calculate PathSegments based on number of base pairs in the model ***/
			var cubicPath = Paths.cubicBezier(pathControls.vertices, pathSegments, this.pathClosed);
			var cubicGeom = cubicPath.createPointsGeometry(pathSegments);
			for (var j = cubicGeom.vertices.length - 1; j >= 0; j--) {
				var cubicGeomColor = new THREE.Color(colors[j]);
				cubicGeom.colors.unshift(cubicGeomColor);
			}
			cubicGeom.name = "cubicGeom";

			// ********************************************
			// * MODEL SCALE = 1unit : 1nanometer         *
			// * 1 micrometer (Âµm) = 1000 nanometers (nm) *
			// ********************************************
			// Eukaryotic animal cells diamter == 20 Âµm (10 - 30 Âµm) = 10000 units radius
			// var cellRadius = 10000;
			// Nucleus diameter == 6 Âµm (3 - 10 micrometers) = 3000 units radius
			// var nucelusRadius = 20;
			// Chromatin diameter == 30nm
			var pathLength = cubicPath.getLength();
			var chromatinRadius = 15; // 30nm * 0.5
			// Chromatin density == 1080 BP : 11nm
			var chromatinLength = this.genomeLength * 11 / 1080;
			this.radius = (pathLength * chromatinRadius) / chromatinLength;

			// Generate Chromatin model
			var chromatinFiber = new THREE.Object3D(); // unmerged network
			var chromatinBounds = new THREE.Geometry(); // to calculate merged bounds

			for ( var i = 0 ; i < pathSegments; i++) {
				// cap if end segment
				this.endcap = ( i === 0 || i === pathSegments - 1 ) ? false : true ;
				// color linked to scene scope
				
				var segmentColor = colors[i];
				var segmentMaterial = new THREE.MeshLambertMaterial({
					color: segmentColor,
					emissive: segmentColor,
					vertexColors: THREE.VertexColors,
					opacity: 1.0, 
					transparent: false,
					wireframe: false
				});
				var segment = segmentGeometry(cubicGeom.vertices[i], cubicGeom.vertices[i+1], this );
				chromatinBounds.merge(segment);

				var chromatinSegment = new THREE.Mesh(segment, segmentMaterial);
				chromatinSegment.name = "segment-" + (i + 1);
				chromatinFiber.add(chromatinSegment);
			}

			chromatinBounds.computeBoundingSphere();
			chromatinFiber.boundingSphere = chromatinBounds.boundingSphere;
			chromatinFiber.name = "Chromatin Fiber";
			
			return chromatinFiber;
		};
	}
	
	function getGeometry(data) {
		var offset = 0, vertex,
			 vertexGeometry = new THREE.Geometry();
		var totalVertices = data.length;
		while ( offset < totalVertices ) {
			vertex = new THREE.Vector3();
			vertex.x = data[ offset ++ ];
			vertex.y = data[ offset ++ ];
			vertex.z = data[ offset ++ ];
			vertexGeometry.vertices.push( vertex );
		}
		vertexGeometry.name = "Chromatin Geometry";
		return vertexGeometry;
	}

	function segmentGeometry (pointX, pointY, props) {
		var newGeometry;
		/* edge from X to Y */
		var segmentDirection = new THREE.Vector3().subVectors( pointY, pointX );
		var segmentOrientation = new THREE.Matrix4();
		/* THREE.Object3D().up (=Y) default orientation for all objects */
		segmentOrientation.lookAt(pointX, pointY, new THREE.Object3D().up);
		/* rotation around axis X by -90 degrees
		 * matches the default orientation Y
		 * with the orientation of looking Z */
		var segmentRotation = new THREE.Matrix4();
		segmentRotation.set(	1, 0, 0, 0,
								0, 0, 1, 0,
								0,-1, 0, 0,
								0, 0, 0, 1 );
		segmentOrientation.multiply(segmentRotation);
		segmentOrientation.setPosition( pointX.add(pointY).multiplyScalar(0.5) );
		newGeometry = new THREE.CylinderGeometry( props.radius, props.radius, segmentDirection.length(), props.radiusSegments, props.curveSegments, props.endcap);
		newGeometry.applyMatrix(segmentOrientation);
		
		return newGeometry;
	}
		
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.factory('Cluster', Cluster);

	// constructor for cluster models ensemble
	function Cluster(VERBOSE, $log, Color) {
		return function(data, centroidIndex, layer, settings) {
			if (VERBOSE) $log.debug(layer);

			var defaults = {
				visible: true,
			};	
			settings = settings || {};
			angular.extend(this, angular.copy(defaults), settings);

			// Convert Data (single Model / set of Particles) to Vector triplets
			var clusterBufferGeometry = new THREE.BufferGeometry(); // to calculate merged bounds
			var layerColors = Color.THREEColorsFromHex(layer);

			// Generate Cluster model
			var clusterEnsemble = new THREE.Object3D(); // unmerged network

			for ( var i = 0 ; i < data.length; i++) {
				var modelComponents = data[i];
				clusterBufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( modelComponents, 3 ) );
				var modelGeometry = getModelGeometry(modelComponents);
					modelGeometry.colors = layerColors;

				var modelColor = layer[i];
				var modelMaterial = new THREE.LineBasicMaterial({
					color: new THREE.Color(this.color),
					opacity: this.modelOpacity,
					transparent: this.transparent,
					linewidth: this.linewidth,
					fog: this.fog
				});
				var centroidMaterial = new THREE.LineBasicMaterial({
					opacity: this.centroidOpacity, 
					transparent: this.transparent,
					linewidth: this.linewidth,
					vertexColors: THREE.VertexColors,
					fog: this.fog
				});
				if (i == centroidIndex) {
					modelMaterial = centroidMaterial;
				}
				var model = new THREE.Line(modelGeometry, modelMaterial);
				model.name = "model-"+ i;
				clusterEnsemble.add(model);
			}
			clusterBufferGeometry.computeBoundingBox();
			// clusterBufferGeometry.computeBoundingSphere();
			clusterEnsemble.boundingBox = clusterBufferGeometry.boundingBox;
			// clusterEnsemble.boundingSphere = clusterBufferGeometry.boundingSphere;
			clusterEnsemble.BufferGeometry = clusterBufferGeometry;
			clusterEnsemble.name = "Cluster Ensemble";
			return clusterEnsemble;
		};
	}
	
	function getModelGeometry(components) {
		var offset = 0, vertex,
			 modelGeometry = new THREE.Geometry();

		var totalVertices = components.length;
		while ( offset < totalVertices ) {
			vertex = new THREE.Vector3();
			vertex.x = components[ offset ++ ];
			vertex.y = components[ offset ++ ];
			vertex.z = components[ offset ++ ];
			modelGeometry.vertices.push( vertex );
		}
		return modelGeometry;
	}

})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentSceneClusters', tkComponentSceneClusters);

	function tkComponentSceneClusters(VERBOSE, $log, THREEService, THREEPlugins, Particles, Cluster) {
		return {
			restrict: 'EA',
			scope: { 
				title: '@',
				view: '=',
				clusters: '=',
				layer:'=',
				mousemove: '&'
			},
			templateUrl: 'assets/templates/scene-clusters.html',
			link: function postLink( scope, element, attrs ) {
				if (VERBOSE) $log.debug(scope);

				/*
				 * NOTE: this directive generates all clusters
				 *       (rather than a single scene for each)
				 *       for efficient use of THREEjs renderer 
				 */
				THREEPlugins.load(["TrackballControls","OrbitControls"]).then(function(THREE) {
					// DOM variables
					var container, elementParent;
					var width, height, contW, contH, windowHalfX, windowHalfY;

					// THREE variables
					var renderer = THREEService.getRenderer();

					var scenes = [];
					var camera, cameraPosition, cameraTarget, cameraTranslate;
					var ambientLight, pointLight;
					var controls, playback;
					var mouseX = 0, mouseY = 0;
					var colCount, tileGutter;
					var viewportUnit, viewportLeft, viewportBottom, viewportWidth, viewportHeight;

					scope.init = function () {

						// CONTAINER
						/* component-controller == element[0].children[0]
						 * - component-header == element[0].children[0].children[0]
						 * - component-body == element[0].children[0].children[3]
						 * - component-body-list == element[0].children[0].children[3].children[0]
						 */
						container = element[0].children[0].children[3].children[0];
						// PARENT #main-content from main.html
						elementParent = element.parent().parent()[0];
						var elementPadding = parseInt(window.getComputedStyle(elementParent, null).getPropertyValue('padding'));

 						// clientWidth and clientHeight ie. no margins nor padding
						width = elementParent.clientWidth - (elementPadding * 2);
						height = elementParent.clientHeight - (elementPadding * 2);

						// var background = scope.view.settings.background;
						// var clearColor = "0x" + background.substring(1);
						// renderer.setClearColor( clearColor );
						renderer.setSize( width, height );
						container.appendChild( renderer.domElement );

						// Values from JSON
						var rowHeight = scope.view.settings.rowHeight;
						var rowSplit = rowHeight.split(':');
						var rowRatio = parseInt(rowSplit[0], 10) / parseInt(rowSplit[1], 10);
						tileGutter = parseInt(scope.view.settings.gutter); // to remove px
						colCount = scope.view.settings.cols;

						// *** Derived from Angular Material grid-list.js lines 221-267 ***
						// Fraction of the gutter size that each column takes up.
						var hGutterShare = (colCount - 1) / colCount;
						// Percent of the available horizontal space that one column takes up.
						var hShare = 1 / colCount;
						var sharedGutter = tileGutter * hGutterShare;
						viewportUnit = (width * hShare) - sharedGutter; // ie. previous column's right edge
						viewportWidth = viewportUnit;
						viewportHeight = viewportWidth * rowRatio;

						// CAMERA
						camera = new THREE.PerspectiveCamera( scope.view.viewpoint.fov, rowRatio, scope.view.viewpoint.near, scope.view.viewpoint.far );
						camera.position.fromArray(scope.view.viewpoint.camera);
						camera.name = "Scene Camera";
						
						controls = new THREE.TrackballControls(camera, renderer.domElement);

						angular.forEach( scope.clusters, function(cluster, index) {

							// SCENE
							scenes[index] = new THREE.Scene();

							// TADkit variables
							var particles, bundle;

							// GEOMETRY: PARTICLES
							particles = new Particles( cluster.data[cluster.centroidIndex], scope.layer, scope.view.settings.particles );
							particles.visible = scope.view.settings.particles.visible;
							scenes[index].add(particles);

							//GEOMETRY: CLUSTER
							bundle = new Cluster( cluster.data, cluster.centroidIndex, scope.layer, scope.view.settings.cluster );
							bundle.visible = scope.view.settings.cluster.visible;
							bundle.name = bundle.name + " " + index;
							scenes[index].add(bundle);

						});

						// SET CAMERA ORIENTATION
						cameraPosition = scope.view.viewpoint.camera;
						cameraTarget = scope.view.viewpoint.target;
						cameraTranslate = scope.view.viewpoint.translate;

						scope.lookAtTarget(cameraPosition, cameraTarget, cameraTranslate);
					};

					scope.lookAtTarget = function (position, target, translate) {
							position = position || new THREE.Vector3( 50000, 50000, 50000 );
							var origin = new THREE.Vector3(0,0,0);
							target = target || origin;
							translate = translate || 500;
							// Target on Origin and Translate back
							// (creates consistent view orientation)
							camera.position.set(position.x, position.y, position.z);
							camera.lookAt(origin);
							camera.translateZ(translate);
							// Retarget on target
							camera.lookAt(target);
							camera.updateMatrixWorld();
							// Controls target
							controls.target.copy(position);
							controls.update();
					};

					// EVENT WHICH TRIGGERS RENDER
					// element.on('mousemove', function(event) {
					// 	mouseX = ( event.clientX - width / 2 );
					// 	// mouseY = ( event.clientX - width / 2 );
					// 	scope.render();
					// });

					// scope.updateCamera = function( camera, scene, mouseX, mouseY ) {

					// 	// *** CHANGE TO CIRCLE CURRENT cameraTarget ****

					// 	camera.position.x += mouseX * 0.5;
					// 	camera.position.x = Math.max( Math.min( camera.position.x, 4000 ), -4000 );
					// 	// camera.position.y += mouseY * 0.5;
					// 	// camera.position.y = Math.max( Math.min( camera.position.y, 4000 ), -4000 );

					// 	camera.lookAt( scene.position );
					// };


					// *** TEMPORARY FIX FOR SPRITE LOADING
					// *** Change to THREE.ImageLoader with THREE.LoadingManager
					var timer = 0;
					var animframe;
					scope.animate = function () {
						if (timer >= 0 && timer < 1) {
							animframe = requestAnimationFrame( scope.animate );
							controls.update();
							scope.render();
							timer++;
							$log.debug("AnimationFrame requested");
						} else {
							cancelAnimationFrame( animframe );
							$log.debug("AnimationFrame canceled");
						}
					};

					scope.render = function () {					
						var colIndex = 1;
						var rowIndex = 1;
						var span = 1;
						angular.forEach( scope.clusters, function(cluster, index) {

							if ( index === 0 ) renderer.clear();

							var scene = scenes[index];
							// scope.updateCamera( camera, scene, mouseX, mouseY );
							controls.update();

							var viewportLeft = (viewportUnit + tileGutter) * (colIndex - 1);
							var viewportBottom = height - (viewportUnit * rowIndex);

							renderer.setViewport( viewportLeft, viewportBottom, viewportWidth, viewportHeight );
							renderer.setScissor( viewportLeft, viewportBottom, viewportWidth, viewportHeight );
							renderer.enableScissorTest ( true );
							renderer.setClearColor( "#ffffff" );
							renderer.render( scene, camera, null, true ); // forceClear == true

							if ( colIndex === colCount ) {
								colIndex = 1;
								rowIndex++;
							} else {
								colIndex++;
							}
						});
						$log.debug(camera);
					};

					// Begin
       				 angular.element(document).ready(function() {
						scope.init();
						// scope.render();
						// *** TEMP FIX for sprite load - see above lines 137-152
						// *** ie. should render clusters directly without animation
						scope.animate();
		      		});

				});
			}
		};
	}
})();

(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentSceneFloatingtad', tkComponentSceneFloatingtad);

	function tkComponentSceneFloatingtad($rootScope, THREEService, THREEPlugins) {
		return {
			restrict: 'EA',
			link: function(scope, element, attrs) {
				THREEPlugins.load(["TrackballControls","OrbitControls"]).then(function(THREE) {
					var container, viewsize, camera, scene;
					var geometry, material, network, controls;
					var renderer = THREEService.getRenderer();
					var animation;

					scope.init = function() {
						container =  element[0];
						viewsize = container.clientWidth;

						renderer.setSize( viewsize, viewsize );
						container.appendChild( renderer.domElement );

						scene = new THREE.Scene();

						camera = new THREE.PerspectiveCamera( 50, 1, 150, 650 );
						camera.position.z = 500;
						scene.add(camera);

						geometry = new THREE.TorusKnotGeometry( 100, 30, 100, 16 );

						material = new THREE.MeshDepthMaterial({
							// morphTargets: false,
							wireframe: true,
							// wireframeLinewidth: 1
						});

						network = new THREE.Mesh( geometry, material );
						network.name = "Floating TAD";
						scene.add(network);
							
						// controls = new THREE.TrackballControls( camera, renderer.domElement );
						// controls.minDistance = 450;
						// controls.maxDistance = 550;

					};

					// -----------------------------------
					// Event listeners
					// -----------------------------------
					$rootScope.$on('$stateChangeStart', function() {
						cancelAnimationFrame( animation );
					});

					// -----------------------------------
					// Draw and Animate
					// -----------------------------------
					scope.animate = function() {
						animation = requestAnimationFrame( scope.animate );
						// controls.update();
						scope.render();
					};

					scope.render = function() {
						network.rotation.x += 0.006;
						network.rotation.y += 0.006;
						renderer.render( scene, camera, null, true ); // forceClear == true
					};

					scope.init();
					scope.animate();
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.factory('Network', Network);

	// create one line between each pair in dataset
	function Network(VERBOSE, $log, Color, Particles, Networks) {
		return function(data, layer, settings) {
			if (VERBOSE) $log.debug(data);
			if (VERBOSE) $log.debug(layer);

			// Uses THREE.LineSegments to generate separate lines
			// from an array of vertex pairs

			var defaults = {
				color: "#ff0000",
				size: 200,
				opacity: 0.8,
				map: "assets/img/sphere-glossy.png",
				depthtest: true,
				alphatest: 0.5,
				transparent: true,
				visible: false
			};	
			settings = settings || {};
			angular.extend(this, angular.copy(defaults), settings);

			// Define a color-typed uniform
			var uniforms = {  
				// color: { type: "c", value: new THREE.Color( 0x00ff00 ) },
				// alpha: { type: "f", value: 1.0 }
			};
			var attributes = {  
				alpha: { type: 'f', value: [] }
			};
			var parameters = {
				uniforms: uniforms,
				// attributes: attributes,
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent,
				vertexColors: THREE.VertexColors,
				// side: THREE.DoubleSide,
				// blending: THREE.AdditiveBlending, // black is transparent
				transparent: true //this.transparent
			};
			var shaderMaterial = new THREE.ShaderMaterial(parameters);

			var dataLength = data.length / 3;
			var totalPairs = ((dataLength * dataLength) - dataLength) * 0.5;

			var vertexPairs = getVertexPairs(data, totalPairs);
			var vertexRGB = layer.RGB;
			var vertexAlpha = layer.alpha;

			var geometry = new THREE.BufferGeometry();
			geometry.addAttribute( 'position', new THREE.BufferAttribute( vertexPairs, 3 ) );
			geometry.addAttribute( 'color', new THREE.BufferAttribute( vertexRGB, 3 ) );
			geometry.addAttribute( 'alpha', new THREE.BufferAttribute( vertexAlpha, 1 ) );
			geometry.computeBoundingSphere();

			var nodeMap = null; // render only point
			if (this.map) {
				var loader = new THREE.TextureLoader();
				loader.load(
					this.map,
					function ( texture ) {
						nodeMap = texture;
					},
					// Function called when download progresses
					function ( xhr ) {
						$log.info( (xhr.loaded / xhr.total * 100) + '% loaded' );
					},
					// Function called when download errors
					function ( xhr ) {
						$log.error( 'An error happened' );
					}
				);
			}

			var nodesMaterial = new THREE.PointsMaterial({
				color: this.color,
    			vertexColors: THREE.VertexColors,
				size: this.size,
				opacity: this.opacity,
				map: nodeMap,
				depthTest: this.depthtest,
				alphaTest: this.alphatest,
				transparent: this.transparent
			});

			// NETWORK
			// var nodes = new THREE.Points(data, nodesMaterial);
			// nodes.name = "Network Nodes";
			
			// var edges = new THREE.LineSegments(geometry, shaderMaterial);
			// edges.name = "Network Edges";

			// var network = new THREE.Object3D();
			// network.add(edges);
			// network.add(nodes);
			// network.boundingSphere = geometry.boundingSphere;
			var network = new THREE.LineSegments(geometry, shaderMaterial);
			network.name = "Network Graph";
			if (VERBOSE) $log.debug(network);
			return network;
		};
	}

	function getVertexPairs($log, data, totalPairs) {
		// from an array of vertex pairs
		// eg. [x1,y1,z1,x2,y2,z2,x3,y3,z3,...xn,yn,zn]
		// to a matrix of all-to-all connections
		// eg. [x1,y1,z1,x2,y2,z2,x1,y1,z1,x3,y3,z3,...xn,yn,zn,xm,ym,zm]
		// such that all point pairs are represented uniquely
		// ie. one half of matrix where array length = (n^2-n)/2
		// eg.  1 2 3 4
		//     1  x x x  ==  1-2 1-3 1-4    3
		//     2    x x  ==  2-3 2-4      + 2
		//     3      x  ==  3-4          + 1
		//     4         ==  ((4*4)-4)*0.5  = 6 pairs of vertices
		var vertexPairs = new Float32Array( totalPairs * 6); // 6 ie. 2 * xyz
		var pairPos = 0;
		for (var i = 0; i < data.length; i += 3) {
			var vertex1 = i;
			for (var j = i + 3; j < data.length; j += 3) {
				var vertex2 = j;
				$log.debug(pairPos);
				$log.debug(data[vertex1]+","+data[vertex1+1]+","+data[vertex1+2]);
				$log.debug(data[vertex2]+","+data[vertex2+1]+","+data[vertex2+2]);
				// from vertex
				vertexPairs[pairPos] = data[vertex1]; pairPos++;
				vertexPairs[pairPos] = data[vertex1 + 1]; pairPos++;
				vertexPairs[pairPos] = data[vertex1 + 2]; pairPos++;
				// to vertex
				vertexPairs[pairPos] = data[vertex2]; pairPos++;
				vertexPairs[pairPos] = data[vertex2 + 1]; pairPos++;
				vertexPairs[pairPos] = data[vertex2 + 2]; pairPos++;
			}
		}
		vertexPairs.name = "Network Vertex Pairs";
		return vertexPairs;
	}

})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.factory('Particles', Particles);

	// constructor for chromatin model instances
	function Particles(THREETextures) {
		return function(data, colors, settings) {
			var defaults = {
				particles: 0,
				visible: true,
				color: "#fff000",
				size: 200,
				opacity: 0.8,
				map: "particle",
				depthtest: true,
				alphatest: 0.5,
				transparent: true
			};
			settings = settings || {};
			angular.extend(this, angular.copy(defaults), settings);

			var particlesGeometry = getGeometry(data);
			particlesGeometry.computeBoundingSphere();

			var vertexColors = [];
			for( var i = 0; i < particlesGeometry.vertices.length; i++ ) {
				// BASE COLOR
				vertexColors[i] = new THREE.Color("rgb(255,255,255)");
			}
			particlesGeometry.colors = vertexColors;

			// OJO! Â¿Â¿Â¿IS THREE module CHECKING IF TEXTURE ALREADY LOADED???
			var particleTexture = THREETextures.get(this.map);

			var particlesMaterial = new THREE.PointsMaterial({
				color: this.color,
    			vertexColors: THREE.VertexColors,
				size: this.size,
				opacity: this.opacity,
				map: particleTexture,
				depthTest: this.depthtest,
				alphaTest: this.alphatest,
				transparent: this.transparent
			});

			var particles = new THREE.Points( particlesGeometry, particlesMaterial );
			// particles.sortParticles = true;
			particles.name = "Particles Cloud";
			
			return particles;
		};
	}
	
	function getGeometry(data) {
		var offset = 0, vertex,
			 vertexGeometry = new THREE.Geometry();
		var totalVertices = data.length;
		while ( offset < totalVertices ) {
			vertex = new THREE.Vector3();
			vertex.x = data[ offset ++ ];
			vertex.y = data[ offset ++ ];
			vertex.z = data[ offset ++ ];
			vertexGeometry.vertices.push( vertex );
		}
		vertexGeometry.name = "Particles Geometry";
		return vertexGeometry;
	}
		
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('SceneController', SceneController);

	function SceneController($log, $state, $scope, Clusters) {

		$scope.optionsState = false;
		$scope.toggleOptions = function() {
			$scope.optionsState = !$scope.optionsState;
		};

		$scope.toggle = function(bool) {
			bool = !bool;
			$log.debug(bool);
		};

		// On click set selected cluster
		$scope.selectCluster = function(index) {
			Clusters.setCluster(index + 1);
			var centroidRef = Clusters.getCentroidRef();
			$log.info("Current Cluster: " + (index + 1) + " (Centroid Model: " + centroidRef + ")");
			$state.go('browser');
		};

		// $scope.keyControls = function (e, component) {
		// 	if (event.keyCode === 32 || event.charCode === 32) {
		// 		component.view.controls.autoRotate = !component.view.controls.autoRotate; 
		// 	}
		// };

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentScene', tkComponentScene);

	function tkComponentScene($log, $rootScope, THREEService, THREEPlugins, Particles, Chromatin, Network) {
		return {
			restrict: 'EA',
			scope: { 
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=',
				state: '=',
				currentmodel: '=',
				proximities: '=',
				currentlayer: '='
			},
			templateUrl: 'assets/templates/scene.html',
			link: function postLink(scope, element, attrs) {
				THREEPlugins.load(["TrackballControls","OrbitControls"]).then(function(THREE) {
					// DOM variables
					var component, viewport;
					var width, height, contW, contH, windowHalfX, windowHalfY;

					// THREE variables
					var renderer = THREEService.getRenderer();
					var animation;

					var scene;
					var camera, cameraPosition, cameraTarget, cameraTranslate;
					var ambientLight, pointLight;
					var autoplay, controls;

					// TADkit variables
					var particles, chromatin, network;
					var particleOriginalColor = new THREE.Color();
					var positionOriginalColor = new THREE.Color();
					var highlightColor = new THREE.Color("rgb(0,0,0)"); // add to scene component

					scope.init = function () {

						// VIEWPORT
						/* component = element[0].parentNode
						 * component-controller == element[0].children[0]
						 * - component-header == element[0].children[0].children[0]
						 * - component-body == element[0].children[0].children[3]
						 */
						
						viewport = element[0].children[0].children[3];

						// width = component.clientWidth; // NEED TO WAIT UNTIL DOM LOADED
						width = parseInt(scope.state.width); // USE UNTIL DOM CHECK AVAILBLE
						// height = component.clientHeight;
						height = parseInt(scope.state.height); // USE UNTIL DOM CHECK AVAILBLE
				
						var background = scope.view.settings.background;
						// var clearColor = "0x" + background.substring(1);
						// renderer.setClearColor( clearColor );
						renderer.setSize( width, height );
						viewport.appendChild( renderer.domElement );

						// SCENE
						scene = new THREE.Scene();

						// CAMERA
						camera = new THREE.PerspectiveCamera( scope.view.viewpoint.fov, ( width / height) , scope.view.viewpoint.near, scope.view.viewpoint.far );
						camera.position.fromArray(scope.view.viewpoint.camera);
						camera.name = "Scene Camera";
						scene.add(camera);

						// CONTROLS
						// Use TrackballControls for interaction
						controls = new THREE.TrackballControls(camera, renderer.domElement);
						// Use OrbitControls for autoRotate
						autoplay = new THREE.OrbitControls(camera, renderer.domElement);
						autoplay.autoRotate = scope.view.controls.autoRotate;
						autoplay.autoRotateSpeed = scope.view.controls.autoRotateSpeed;
						// interaction FALSE so as not to conflict with controls
						autoplay.enableZoom = false;
						autoplay.enableRotate = false;
						autoplay.enablePan = false;
						autoplay.enableKeys = false;

						// AXIS
						// TODO: Make local axisHelper
						var axisHelper = new THREE.AxisHelper( scope.view.settings.axis.size );
						axisHelper.visible = scope.view.settings.axis.visible;
						axisHelper.name = "Axis";
						scene.add( axisHelper );

						// LIGHTS
						// Ambient
						var ambientColor = scope.view.settings.lighting.ambient;
						ambientLight = new THREE.AmbientLight(ambientColor);
						ambientLight.name = "Scene Ambient Light";
						// scene.add(ambientLight);
						
						// GEOMETRY: PARTICLES
						particles = new Particles(scope.currentmodel.data, scope.currentlayer.colors.particles, scope.view.settings.particles);
						// particles = new Particles(scope.model.data, scope.layer.colors.particles, scope.view.settings.particles);
						particles.visible = scope.view.settings.particles.visible;
						scene.add(particles);

						//GEOMETRY: CHROMATIN
						chromatin = new Chromatin(scope.currentmodel.data, scope.currentlayer.colors.chromatin, scope.view.settings.chromatin);
						// chromatin = new Chromatin(scope.model.data, scope.layer.colors.chromatin, scope.view.settings.chromatin);
						chromatin.visible = scope.view.settings.chromatin.visible;
						scene.add(chromatin);
						scope.view.settings.chromatin.radius = chromatin.boundingSphere.radius;

						// GEOMETRY: MESH
						// network = new Network(scope.proximities.positions, scope.proximities.distances, scope.view.settings.network);
						network = new Network(scope.data, scope.layer.colors.network, scope.view.settings.network);
						network.visible = scope.view.settings.network.visible;
						scene.add(network);

						// UPDATE CAMERA TARGET
						cameraPosition = chromatin.boundingSphere.center;
						cameraTarget = chromatin.boundingSphere.center;
						cameraTranslate = chromatin.boundingSphere.radius * scope.view.viewpoint.scale;
						scope.lookAtTAD(cameraPosition, cameraTarget, cameraTranslate);

						// Point
						var pointColor = scope.view.settings.lighting.color;
						var pointIntensity = scope.view.settings.lighting.intensity;
						pointLight = new THREE.PointLight(pointColor, pointIntensity);
						pointLight.name = "Scene Light";
						camera.add(pointLight);
						var lightOffset = cameraTranslate * 0.5; // Up and to the left
						pointLight.position.set(lightOffset,lightOffset,(lightOffset * -1.0));
						// Point Light Helper
						var sphereSize = 100;
						var pointLightHelper = new THREE.PointLightHelper(pointLight, sphereSize);
						// scene.add(pointLightHelper);
						
						// FOG SCENE
						var fogNear = cameraTranslate * scope.view.viewpoint.fogNear,
							fogFar = cameraTranslate * scope.view.viewpoint.fogFar;
						if (scope.view.viewpoint.fog) scene.fog = new THREE.Fog(background,fogNear,fogFar);

						// EVENT LISTENERS / SCOPE WATCHERS
						// window.addEventListener( 'resize', scope.onWindowResize, false );

						/* Watch for changes */

						// var componentOptions = [
						// 	 'view.settings.particles.visible',
						// 	 'view.settings.chromatin.visible',
						// 	 'view.controls.autoRotate',
						// 	 'view.settings.axis.visible'
						// 	 ];
						// scope.$watchGroup( componentOptions, function( newValues, oldValues ) {
						// 	angular.forEach( newValues, function(value, index) {
						// 		if ( newValues[index] !== oldValues[index] ) {
						// 			$log.debug( value );
						// 		}
						// 	});
						// });

					// FIX: NOT REDRAWING SCENE IF THE ONLY VISBLE OBJECT IS TOGGLED OFF
						scope.$watch('view.controls.autoRotate', function( newValue, oldValue ) {
							if ( newValue !== oldValue ) {
								// autoplay.autoRotate = !autoplay.autoRotate;
								autoplay.autoRotate = scope.view.controls.autoRotate;
							}
						});
						scope.$watch('view.settings.axis.visible', function( newValue, oldValue ) {
							if ( newValue !== oldValue ) {
								axisHelper.visible = !axisHelper.visible;
							}
						});
						scope.$watch('view.settings.particles.visible', function( newValue, oldValue ) {
							if ( newValue !== oldValue ) {
								particles.visible = !particles.visible;
							}
						});
						scope.$watch('view.settings.chromatin.visible', function( newValue, oldValue ) {
							if ( newValue !== oldValue ) {
								chromatin.visible = !chromatin.visible;
							}
						});
						scope.$watch('view.settings.network.visible', function( newValue, oldValue ) {
							if ( newValue !== oldValue ) {
								network.visible = !network.visible;
							}
						});

						// /* Watch for Particles colors */
						// scope.$watch('currentlayer.colors.particles', function( newColors, oldColors ) { // cant deep watch as change through set on service
						// 	if ( newColors !== oldColors ) {
						// 		// var particleCount = particles.children.length;
						// 		// for (var i = 0; i < particleCount; i++) {
						// 		// 	var newParticleColor =  new THREE.Color(newLayer.colors.particles[i]);
						// 		// 	particles.children[i].material.color = newParticleColor;
						// 		// }
						// 	}
						// });

						// /* Watch for Chromatin colors */
						scope.$watch('currentlayer.colors.chromatin', function( newColors, oldColors ) { // cant deep watch as change through set on service
							if ( newColors !== oldColors ) {
								var chromatinCount = chromatin.children.length;
								for (var i = 0; i < chromatinCount; i++) {
									var newChromatinColor =  new THREE.Color(newColors[i]);
									chromatin.children[i].material.color = newChromatinColor;
									chromatin.children[i].material.emissive = newChromatinColor;
								}
							}
						});

						// /* Watch for Network colors */
						scope.$watch('currentlayer.colors.network', function( newColors, oldColors ) { // cant deep watch as change through set on service
							if ( newColors !== oldColors ) {
								network.geometry.addAttribute( 'color', new THREE.BufferAttribute( newColors.RGB, 3 ) );
								network.geometry.addAttribute( 'alpha', new THREE.BufferAttribute( newColors.alpha, 1 ) );
							}
						});

						/* Watch for Browser-wide Position updates */
						scope.$watch('settings.current.particle', function( newParticle, oldParticle ) {
							if ( newParticle !== oldParticle ) {

								// SET PARTICLE CURSOR COLOR
								if (particleOriginalColor) particles.geometry.colors[(oldParticle - 1)] = particleOriginalColor;
								particleOriginalColor = particles.geometry.colors[(newParticle - 1)];
								particles.geometry.colors[(newParticle - 1)] = highlightColor;
								particles.geometry.colorsNeedUpdate = true;
							}
						});

						/* Watch for Browser-wide Position updates */
						scope.$watch('settings.current.segment', function( newSegment, oldSegment ) {
							if ( newSegment !== oldSegment ) {

								// SET CHROMATIN CURSOR COLOR								
								var segmentPrevious = chromatin.getObjectByName( "segment-" + oldSegment );
								if (positionOriginalColor) {
									segmentPrevious.material.color = positionOriginalColor;
									segmentPrevious.material.emissive = positionOriginalColor;
								}

								var segmentCurrent = chromatin.getObjectByName( "segment-" + newSegment );
								positionOriginalColor = segmentCurrent.material.color;

								segmentCurrent.material.color = highlightColor;
								segmentCurrent.material.emissive = highlightColor;
							}
						});

					};

					// -----------------------------------
					// Event listeners
					// -----------------------------------
					scope.onWindowResize = function () {
						scope.resizeCanvas();
					};

					$rootScope.$on('$stateChangeStart', function() {
						// cancelAnimationFrame( animation );
						$log.info("$stateChangeStart");
					});
					$rootScope.$on('$stateNotFound', function() {
						$log.warn("$stateNotFound");
					});
					$rootScope.$on('$stateChangeSuccess', function() {
						$log.info("$stateChangeSuccess");
					});
					$rootScope.$on('$stateChangeError', function() {
						$log.warn("$stateChangeError");
					});
					// element.on('mousemove', function(event) {
					// 	// mouseX = ( event.clientX - width / 2 );
					// 	// mouseY = ( event.clientX - width / 2 );
					// 	scope.animate();
					// });

					// -----------------------------------
					// Updates
					// -----------------------------------
					scope.resizeCanvas = function () {

						contW = viewport.parentNode.clientWidth * 0.66;
						contH = contW * 0.66;
						windowHalfX = contW / 2;
						windowHalfY = contH / 2;

						camera.aspect = contW / contH;
						camera.updateProjectionMatrix();

						renderer.setSize( contW, contH );
					};

					scope.lookAtTAD = function (position, target, translate) {
						position = position || new THREE.Vector3( 50000, 50000, 50000 );
						var origin = new THREE.Vector3(0,0,0);
						target = target || origin;
						translate = translate || 500;
						// Target on Origin and Translate back
						// (creates consistent view orientation)
						camera.position.set(position.x, position.y, position.z);
						camera.lookAt(origin);
						camera.translateZ(translate);
						// Retarget on target
						camera.lookAt(target);
						camera.updateMatrixWorld();
						// Controls target
						controls.target.copy(position);
					};

					// -----------------------------------
					// Draw and Animate
					// -----------------------------------
					scope.animate = function () {
						animation = requestAnimationFrame( scope.animate );
						// autoplay.update();
						controls.update();
						scope.render();
					};

					scope.render = function () {
						renderer.render( scene, camera, null, true ); // forceClear == true
					};

					// Begin
					scope.init();
					scope.animate();
				});
			}
		};
	}
})();

(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkComponentTrackBarchart
	 * @scope
	 * @restrict EA
	 * @param {Object} type Track type.
	 * @param {Object} title Track title.
	 * @param {Array} settings Track settings.
	 * @param {Array} view Track view.
	 * @param {Array} data Track data.
	 * @param {Array} layer Value for toggle in template.
	 * @param {function} togglelayer Toggle function in template.
	 *
	 * @description
	 * Generates a d3 Barchart from the supplied data.

	 * @example
	 * <example>
	 * 	<file name="index.html">
	 * 		<tk-component-track-barchart></tk-component-track-barchart>
	 * 	</file>
	 * </example>
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkComponentTrackBarchart', tkComponentTrackBarchart);

	function tkComponentTrackBarchart(VERBOSE, $log, d3Service, Settings) {    
		return {
			restrict: 'EA',
			scope: {
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=', /* used in template */
				togglelayer: '&' /* used in template */
			},
			templateUrl: 'assets/templates/track.html',
			link: function(scope, element, attrs) {
				if (VERBOSE) $log.debug(scope);

				d3Service.load().then(function(d3) {

					scope.safeApply = function(fn) {
						var phase = this.$root.$$phase;
						if(phase == '$apply' || phase == '$digest') {
							if(fn && (typeof(fn) === 'function')) { fn(); }
						} else {
						this.$apply(fn);
						}
					};

 					var data = scope.data;
					var focusStart = scope.view.viewpoint.chromStart;
					var focusEnd = scope.view.viewpoint.chromEnd;
					var focusLength = focusEnd - focusStart + 1; // Resrouces.range...
					var particlesCount = scope.settings.current.particlesCount;

					// SVG GENERATION
					var componentMargin = parseInt(scope.view.settings.margin);
					/* Rebuild margin to maintain D3 standard */
					var margin = {
							top: parseInt(scope.view.settings.padding.top),
							right: parseInt(scope.view.settings.padding.right),
							bottom: parseInt(scope.view.settings.padding.bottom),
							left: parseInt(scope.view.settings.padding.left)
						},
						scale = 4,
						trackHeight = parseInt(scope.view.settings.heightInner),
						nodeHeight = 10,
						nodePadding = 0,
						nodeColor = scope.view.settings.color,
						harmonicsColor = scope.layer.palette[0],
						lowerBoundsColor = scope.layer.palette[1];

					// VIEWPORT
					/* component-controller == children[0]
					 * - component-header == children[0]
					 * - component-body == children[3]
					 */
					var component = element[0].parentNode;
					var viewport = element[0].children[0].children[3];
					// if with controller use line below
					// var viewport = element[0].children[0].children[3];
					var svg = d3.select(viewport).append('svg');
					var xScale, yScale, axisX, axisY, brush, chart;
					var defs, focus, zoomArea, container, axis, labels, harmonics, lowerBounds, highlight;

					// RESIZE
					scope.$watch(function(){
						var w = component.clientWidth;
						var h = component.clientHeight;
						return w + h;
					}, function() {
						scope.render(data);
					});

					// REDRAW
					scope.$watch('data.dimension', function(newData, oldData) {
						if (newData !== oldData ) {
							data = scope.data;
							scope.render(data);
						}
					});

					// UPDATE
					scope.$watch('settings.current.position', function(newPosition, oldPosition) {
						if ( newPosition !== oldPosition ) {
							scope.update();
						}
					});
					
 				// 	// ZOOM
					// var zoom = d3.behavior.zoom()
					// 	.on("zoom",  function() {
					// 	scope.update();
					// });

					scope.getColor = function(code) {
						var colorCodes = [
											{"type":"harmonic","code":"H","color":"#4CAF50"},
											{"type":"upperBound","code":"L","color":"#0000ff"},
											{"type":"lowerBound","code":"U","color":"#ff00ff"},
											{"type":"contact","code":"C","color":"#00ff00"}
										];
						var color = "#ccc";
						for (var i = colorCodes.length - 1; i >= 0; i--) {
							if (code == colorCodes[i].code) {
								color = colorCodes[i].color;
							}
						}
						return color;
					};

					scope.getOpacity = function(value) {
						var opacity;
						var scaled = value / 5; // 5 being the limit...
						opacity = scaled * scaled;
						return opacity;
					};

					scope.getStrokeWidth = function(value) {
						var strokeWidth = 10;
						var scaled = value / 5; // 5 being the limit...
						strokeWidth = strokeWidth * scaled;
						return strokeWidth;
					};

					scope.render = function(data) {
						svg.selectAll('*').remove();
 
						if (!data) return;

						var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
							height = trackHeight - margin.top - margin.bottom;
						var verticalOffset = height * 0.5;
						var particleWidth = (1 * width) / particlesCount;
						var barWidth = particleWidth;

						// var y0 = Math.max(Math.abs(d3.min(data)), Math.abs(d3.max(data)));

						xScale = d3.scale.linear()
								.range([0, width])
								.domain([focusStart, focusEnd])
								.clamp(true);

						yScale = d3.scale.linear()
								.domain([-5, 5])
								.range([0, height]);

						axisY = d3.svg.axis()
								.scale(yScale)
								.orient("left")
								.ticks(6)
								.outerTickSize(1);

						var highlightWidth = 2;

						brush = d3.svg.brush()
							.x(xScale)
							.extent([0, 0])
							.on("brush", scope.brushed);

						chart = svg.attr('width', width + margin.left + margin.right)
								.attr('height', height + margin.top + margin.bottom)
								.append("g")
								.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
								.call(brush);
								// .call(zoom);
						
						chart.append("g")
							.attr("class", "y axis")
							.append("line")
							.attr("y1", yScale(0))
							.attr("y2", yScale(0))
							.attr("x1", 0)
							.attr("x2", width);


						chart.select(".background")
							.attr("y", height/2)
							.attr("height", height);

						// clipping box to clip overflow
						// solid rect as background also allow mouse events everywhere 
						defs = chart.append("defs")
							.append("clipPath")
							.attr("id", "clip")
							.append("rect")
							.attr("width", width)
							.attr("height", height)
							.style('fill', 'white');

						focus = chart.append("g")
							.attr("class", "focus");

						// zoomArea = focus.append("g")
						// 	.attr("class", "zoom")
						// 	.append("rect")
						// 	.attr("width", width)
						// 	.attr("height", height)
						// 	.style('fill', 'white');

						container = focus.append("g")
							.attr("class", "container")
							.attr('clip-path', 'url(#clip)');
						harmonics  = container.append("g")
							.attr("class", "harmonics");
						lowerBounds  = container.append("g")
							.attr("class", "lowerbounds");

						axis = focus.append("g")
							.attr("class", "axis y")
							.call(axisY);

						labels  = chart.append("g")
							.attr("class", "labels");

						// if (scope.view.viewtype == "default") {
							harmonics.selectAll("rect") // RED
								.data(data.harmonics)
								.enter().append("rect")
								.attr("x", function(d) { return (d[1] * barWidth); } )
								.attr("y", function(d) { return yScale( d[3] ); } )
								.attr("width", barWidth)
								.attr("height", function(d) { return yScale( d[3] ); })
								.style("fill", harmonicsColor)
								// .style("fill-opacity", function(d) { return scope.getOpacity(d[3]); })
								.style("stroke", harmonicsColor)
								.style("stroke-width", 0)
								.append("svg:title")
									.text(function(d,i) { return i + ":" + d; });

							lowerBounds.selectAll("rect") // BLUE
								.data(data.lowerBounds)
								.enter().append("rect")
								.attr("x", function(d) { return (d[1] * barWidth); } )
								.attr("y", function(d) { return yScale( Math.max(0, (d[3] * -1.0))); } )
								.attr("width", barWidth)
								.attr("height", function(d) { return yScale( d[3] ); })
								.style("fill", lowerBoundsColor)
								// .style("fill-opacity", function(d) { return scope.getOpacity(d[3]); })
								.style("stroke", lowerBoundsColor)
								.style("stroke-width", 0)
								.append("svg:title")
									.text(function(d,i) { return i + ":" + d; });

						// }

						highlight = chart.append("rect")
								.attr("id", "highlight")
								.attr("x", function(d) { return xScale( scope.settings.current.position); } )
								.attr("y", 0)
								.attr("width", highlightWidth )
								.attr("height", trackHeight)
								.attr("class", "highlight-follow");
						// highlight
						// 	.call(brush.extent([(scope.settings.current.position), 0]))
						// 	.call(brush.event);
					};

					// UPDATE
					scope.update = function(data) {
						svg.select("#highlight") //.style("visibility", "hidden");
						.attr("x", function(d) { return xScale( scope.settings.current.position ); } );
					};

					// BRUSH
					scope.brushed = function() {

						// scope.safeApply( function() {
							var thisTrack = this;
							scope.safeApply( function() {
								var value = brush.extent()[0];
								if (d3.event.sourceEvent) {
									value = parseInt(xScale.invert(d3.mouse(thisTrack)[0]));
									brush.extent([value, value]);
								}
								highlight.attr("x", xScale(value));

								// UPDATE position
								scope.settings.current.position = value;
								scope.settings.current.particle = Settings.getParticle();
								scope.settings.current.segmentLower = scope.settings.current.position - (scope.settings.current.segment * 5); // * 0.5???
								scope.settings.current.segmentUpper = scope.settings.current.position + (scope.settings.current.segment * 5); // * 0.5???

							});
						// });
					};

					// Initial render
					scope.render(data);
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentBedgraph', tkComponentBedgraph);

	function tkComponentBedgraph(VERBOSE, $log, d3Service) {    
		return {
			restrict: 'EA',
			scope: {
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=', /* used in template */
				togglelayer: '&' /* used in template */
			},
			templateUrl: 'assets/templates/track.html',
			link: function(scope, element, attrs) {
				d3Service.load().then(function(d3) {
					if (VERBOSE) $log.debug(scope);

 					// DATA MANIPULATION >>> MOVE TO CONTROLLER
					var data = scope.data;
					// var assemblyLength = 3200000000; // CALCULATE
					// if (!scope.settings.current.position) scope.settings.current.position = assemblyLength / 2;
					var step = scope.view.settings.step;
					var stepWidth;
					var focusStart = scope.view.viewpoint.chromStart;
					var focusEnd = scope.view.viewpoint.chromEnd;
					// var chrStart = 0;
					// var chrEnd = assemblyLength;
					var focusLength = focusEnd - focusStart;
					// var highlightPosition = focusStart + (stepWidth * scope.settings.current.position);

					// var focusScale = assemblyLength / focusLength;
					// var focusMargin = focusScale * 0.05;
					// focusScale = focusScale - (focusMargin * 2.0);
		
					// var focusCenter = focusLength * 0.5;
					// var assemblyCenter = assemblyLength * 0.5;


					// SVG GENERATION
					var componentMargin = parseInt(scope.view.settings.margin);
					/* Rebuild margin to maintain D3 standard */
					var margin = {
							top: parseInt(scope.view.settings.padding.top),
							right: parseInt(scope.view.settings.padding.right),
							bottom: parseInt(scope.view.settings.padding.bottom),
							left: parseInt(scope.view.settings.padding.left)
						},
						scale = 4,
						trackHeight = parseInt(scope.view.settings.heightInner),
						nodeHeight = trackHeight * 0.5,
						verticalOffset = (trackHeight - nodeHeight) * 0.5,
						nodePadding = 0,
						nodeColor = scope.view.settings.color;

					// VIEWPORT
					/* component-controller == children[0]
					 * - component-header == children[0]
					 * - component-body == children[3]
					 */
					var component = element[0].parentNode;
					var viewport = element[0].children[0].children[3];
					// if with controller use line below
					// var viewport = element[0].children[0].children[3];
					var svg = d3.select(viewport).append('svg');
					var chart, defs;
					var xAxis, prime3Axis, prime5Axis;
					var focus, container, xScale;

					// RESIZE implies complete redraw
					scope.$watch(function(){
						var w = component.clientWidth;
						var h = component.clientHeight;
						return w + h;
					}, function() {
						scope.render(data);
					});

					// REDRAW on new data
					// scope.$watch('data', function(newData) {
					// 	scope.render(newData);
					// }, true);
 					
					// SLIDER
					scope.$watch('settings.current.position', function(newData) {
						scope.update();
					}, true);

 					// ZOOM
					var zoom = d3.behavior.zoom()
						.on("zoom",  function() {
						scope.update();
					});

					scope.render = function(data) {
						svg.selectAll('*').remove();
 
						if (!data) return;
 
							var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
								height = trackHeight - margin.top - margin.bottom;
							stepWidth = (step * width) / focusLength;
							xScale = d3.scale.linear()
									.range([0, width])
									.clamp(true);

							xScale.domain([focusStart, focusEnd]);
					
							xAxis = d3.svg.axis()
									.scale(xScale)
									.orient("top")
									.ticks(0)
									.outerTickSize(0);
							// prime3Axis = d3.svg.axis().orient("left"),
							// prime5Axis = d3.svg.axis().orient("right");

							var highlightWidth = 2; //stepWidth;// * width / focusLength;
							// if (highlightWidth < 4) highlightWidth = 4; 
							// var focusOffset = xScale(assemblyCenter) - xScale(focusCenter);

							chart = svg.attr('width', width + margin.left + margin.right)
									.attr('height', height + margin.top + margin.bottom)
									.append("g")
									.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
									// .call(zoom);
							
							// clipping box to clip overflow
							// solid rect as background also allow mouse events everywhere 
							defs = chart.append("defs")
								.append("clipPath")
								.attr("id", "clip")
								.append("rect")
								.attr("width", width)
								.attr("height", height)
								.style('fill', 'white');

							focus = chart.append("g")
								.attr("class", "focus");

							// var zoomArea = focus.append("g")
							// 	.attr("class", "zoom")
							// 	.append("rect")
							// 	.attr("width", width)
							// 	.attr("height", height)
							// 	.style('fill', 'white');

							container = focus.append("g")
								.attr("class", "container")
								.attr('clip-path', 'url(#clip)');

							// zoom.x(xScale);

							// chart.select(".focus").append("g")
							// 	.attr("class", "x axis")
							// 	.attr("transform", "translate(0," + nodeHeight + ")");
								// .call(xAxis);

							var labels  = chart.append("g")
								.attr("class", "labels");

							// TODO: Use FontAwesome/IcoMoon...
							// node.append('text')
							//     .attr('font-family', 'FontAwesome')
							//     .attr('font-size', function(d) { return d.size+'em'} )
							//     .text(function(d) { return '\uf118' }); 

							var focusGraph = container.selectAll("rect")
								.data(data)
								.enter().append("rect")
								.attr("x", function(d, i) { return Math.floor(xScale(d.start)); } )
								.attr("y", verticalOffset)
								.attr("width", function(d) { return Math.ceil(xScale(d.end) - xScale(d.start)); })
								.attr("height", nodeHeight)
								.attr("class", function(d) { if (d.read == 1) return scope.title; } )
								// .style("fill", nodeColor)
								// .style("fill-opacity", function(d) { return d.read; })
								// .style("stroke", nodeColor)
								// .style("stroke-width", 0)
								.append("svg:title")
								.text(function(d,i) { return d.start + ":" + d.end + "(" + d.read + ")"; });

							var highlight = chart.append("rect")
									.attr("id", "highlight")
									.attr("x", function(d) { return xScale( scope.settings.current.position - (step * 0.5)); } )
									.attr("y", 0)
									.attr("width", highlightWidth )
									.attr("height", trackHeight)
									.attr("class", "highlight-follow");
					};

					scope.update = function() {
						// 	var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
						// 		height = trackHeight - margin.top - margin.bottom;
						// 	stepWidth = (step * width) / focusLength;

						// svg.select("g.x.axis").call(xAxis);
						// container.selectAll("rect")
						// .attr("x", function(d, i) { return (i + 1) * stepWidth; } )	
						// .attr("y", verticalOffset)
						// .attr("width", stepWidth)
						// .attr("height", nodeHeight);

						svg.select("#highlight") //.style("visibility", "hidden");
						.attr("x", function(d) { return xScale( scope.settings.current.position - (step * 0.5)); } );
					};
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentTrackGenes', tkComponentTrackGenes);

	function tkComponentTrackGenes($log, d3Service) {    
		return {
			restrict: 'EA',
			scope: {
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=', /* used in template */
				togglelayer: '&' /* used in template */
			},
			templateUrl: 'assets/templates/track.html',
			link: function(scope, element, attrs) {

				d3Service.load().then(function(d3) {
					scope.safeApply = function(fn) {
						var phase = this.$root.$$phase;
						if(phase == '$apply' || phase == '$digest') {
							if(fn && (typeof(fn) === 'function')) { fn(); }
						} else {
						this.$apply(fn);
						}
					};
 					// DATA MANIPULATION >>> MOVE TO CONTROLLER
					var data = scope.data;
					var assemblyLength = 3200000000; // CALCULATE
					if (!scope.settings.current.position) scope.settings.current.position = assemblyLength / 2;
					var positions = 100; //scope.positions; // == ?
					var focusStart = scope.view.viewpoint.chromStart;
					var focusEnd = scope.view.viewpoint.chromEnd;
					var chrStart = 0;
					var chrEnd = assemblyLength;
					var focusLength = focusEnd - focusStart;
					var positionWidth = 1000; //focusLength / positions; // derive from...?
					// var highlightPosition = focusStart + (positionWidth * scope.settings.current.position);

					var focusScale = assemblyLength / focusLength;
					var focusMargin = focusScale * 0.05;
					focusScale = focusScale - (focusMargin * 2.0);
		
					var focusCenter = focusLength * 0.5;
					var assemblyCenter = assemblyLength * 0.5;


					// SVG GENERATION
					var componentMargin = parseInt(scope.view.settings.margin);
					/* Rebuild margin to maintain D3 standard */
					var margin = {
							top: parseInt(scope.view.settings.padding.top),
							right: parseInt(scope.view.settings.padding.right),
							bottom: parseInt(scope.view.settings.padding.bottom),
							left: parseInt(scope.view.settings.padding.left)
						},
						scale = 4,
						trackHeight = parseInt(scope.view.settings.heightInner),
						nodeHeight = 10,
						nodePadding = 0;

					// VIEWPORT
					/* component-controller == children[0]
					 * - component-header == children[0]
					 * - component-body == children[3]
					 */
					var browserContent = element[0].parentNode;
					var componentRect = element[0].getBoundingClientRect();
					var componentBody = element[0].children[0].children[3];

					var svg = d3.select(componentBody).append('svg');
					var chart, defs;
					var xAxis, prime3Axis, prime5Axis;
					var focus, container, xScale;

					// RESIZE
					scope.$watch(function(){
						var w = browserContent.clientWidth;
						var h = browserContent.clientHeight;
						return w + h;
					}, function() {
						scope.render(data);
						componentRect = element[0].getBoundingClientRect();
					});

					// REDRAW
					scope.$watch('data', function(newData, oldData) {
						if ( newData !== oldData ) {
							scope.render(newData);
						}
					});
					// }, true); // FOR DEEP WATCH
 					
					// SLIDER
					scope.$watch('settings.current.position', function(newPosition, oldPosition) {
						if ( newPosition !== oldPosition ) {
							scope.update();
						}
					});

					// TOOLTIP
					var tooltipWidth = 180; // TODO: get form settings
					var tooltipPadding = 10; // TODO: get form settings
					var backgroundColor = "rgb(76,175,80)"; // TODO: get from App

					// Attributees to pass to <tl-tooltip> (dummy values)
					scope.tooltip = {
						"title" : "Gene",
						"content" : {},
						"styling" : {
							"width" : tooltipWidth,
							"padding" : tooltipPadding,
							"background" : backgroundColor
						}
					};

					var tooltip = d3.select(componentBody).select("tk-tooltip");
						tooltip.style("width", (tooltipWidth + "px") );
						tooltip.style("padding", (tooltipPadding + "px") );									

					function setTooltipContent(d) {
						d["start-end"] = d.start + "-" + d.end;
						d.length = d.end - d.start;

						var sorting = ["id","biotype","start-end","strand","length","assembly_name","description"];
						var content = [];
						angular.forEach(d, function(value, key) {
							key.toLowerCase();
							for (var i = sorting.length - 1; i >= 0; i--) {
								sorting[i].toLowerCase();
								if (key == sorting[i]) {
									var name = key.replace("_name","");
									content.push({"name":name,"value":value});
								}
							}
						});
						scope.safeApply( function() {
							scope.tooltip.title = d.feature_type + ": " + d.external_name;
							scope.tooltip.content = content;
						});
					}


 					// ZOOM
					var zoom = d3.behavior.zoom()
						.on("zoom",  function() {
						scope.update();
					});

					scope.render = function(data) {
						svg.selectAll('*').remove();
 
						if (!data) return;

							var width = browserContent.clientWidth - (2 * componentMargin) - margin.left - margin.right,
								height = trackHeight - margin.top - margin.bottom;

							xScale = d3.scale.linear()
									.range([0, width])
									.clamp(true);

							xScale.domain([focusStart, focusEnd]);

							xAxis = d3.svg.axis()
									.scale(xScale)
									.orient("top")
									.ticks(0)
									.outerTickSize(0);
							// prime3Axis = d3.svg.axis().orient("left"),
							// prime5Axis = d3.svg.axis().orient("right");

							var highlightWidth = 2; //positionWidth * width / focusLength;
							// if (highlightWidth < 1) highlightWidth = 1; 
							var focusOffset = xScale(assemblyCenter) - xScale(focusCenter);

							chart = svg.attr('width', width + margin.left + margin.right)
									.attr('height', height + margin.top + margin.bottom)
									.append("g")
									.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
									// .call(zoom);
							
							// clipping box to clip overflow
							// solid rect as background also allow mouse events everywhere 
							defs = chart.append("defs")
								.append("clipPath")
								.attr("id", "clip")
								.append("rect")
								.attr("width", width)
								.attr("height", height)
								.style('fill', 'white');

							focus = chart.append("g")
								.attr("class", "focus");

							// var zoomArea = focus.append("g")
							// 	.attr("class", "zoom")
							// 	.append("rect")
							// 	.attr("width", width)
							// 	.attr("height", height)
							// 	.style('fill', 'white');

							container = focus.append("g")
								.attr("class", "container")
								.attr('clip-path', 'url(#clip)');

							// zoom.x(xScale);

							var axis = focus.append("g")
								.attr("class", "x axis")
								.attr("transform", "translate(0," + nodeHeight + ")")
								.call(xAxis);

							var labels  = chart.append("g")
								.attr("class", "labels");
								labels.append("text")
									.attr("x", -18)
									.attr("y", 8)
									.style("text-anchor", "right")
									.style("font-size", "10px")
									.text("<<");
								labels.append("text")
									.attr("x", -18)
									.attr("y", 18)
									.style("text-anchor", "right")
									.style("font-size", "10px")
									.text(">>");
// TODO: Use FontAwesome/IcoMoon...
// node.append('text')
//     .attr('font-family', 'FontAwesome')
//     .attr('font-size', function(d) { return d.size+'em'} )
//     .text(function(d) { return '\uf118' }); 

							var focusGraph = container.selectAll("rect")
								.data(data)
								.enter().append("rect")
								.attr("x", function(d) { return Math.floor(xScale(d.start)); } )
								.attr("y", function(d) { if (scope.view.settings.sense) { if (d.strand < 1) {return (nodeHeight);} else {return 0;} } else {return 0;} } )
								.attr("width", function(d) { return Math.ceil(xScale(d.end) - xScale(d.start)); } )
								.attr("height", function(d) { if (scope.view.settings.sense) {return (nodeHeight);} else {return (nodeHeight * 2);} }  )
								.attr("class", function(d) {
									var biotypeClass = d.biotypeStyle;
									if (d.strand < 1) {biotypeClass += " forward-strand";}
									else {biotypeClass += " reverse-strand";}
									return biotypeClass; } )
								.on("mouseover", function(d) {
									setTooltipContent(d);
									tooltip.transition()
										.duration(200)
										.style("opacity", 0.8);
									tooltip.style("left", (d3.event.pageX - (tooltipWidth * 0.5)) + "px");
								})
								.on("mouseout", function(d) {
									tooltip.transition()
										.duration(200)
										.style("opacity", 0);
								});

							var highlight = chart.append("rect")
									.attr("id", "highlight")
									.attr("x", function(d) { return xScale( scope.settings.current.position - (positionWidth * 0.5)); } )
									.attr("y", 0)
									.attr("width", highlightWidth )
									.attr("height", trackHeight)
									.attr("class", "highlight-follow");
					};

					scope.update = function() {
						svg.select("g.x.axis").call(xAxis);
						container.selectAll("rect")
						.attr("x", function(d) { return Math.floor(xScale(d.start)); } )	
						.attr("y", function(d) { if (scope.view.settings.sense) { if (d.strand < 1) {return (nodeHeight);} else {return 0;} } else {return 0;} } )
						.attr("width", function(d) { return Math.ceil(xScale(d.end) - xScale(d.start)); } )
						.attr("height", function(d) { if (scope.view.settings.sense) {return (nodeHeight);} else {return (nodeHeight * 2);} }  );

						svg.select("#highlight") //.style("visibility", "hidden");
						.attr("x", function(d) { return xScale( scope.settings.current.position - (positionWidth * 0.5)); } );
					};
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentTrackProximities', tkComponentTrackProximities);

	function tkComponentTrackProximities(VERBOSE, $log, d3Service, Settings) {    
		return {
			restrict: 'EA',
			scope: {
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=', /* used in template */
				togglelayer: '&' /* used in template */
			},
			templateUrl: 'assets/templates/track.html',
			link: function(scope, element, attrs) {
				if (VERBOSE) $log.debug(scope);

				d3Service.load().then(function(d3) {

					scope.safeApply = function(fn) {
						var phase = this.$root.$$phase;
						if(phase == '$apply' || phase == '$digest') {
							if(fn && (typeof(fn) === 'function')) { fn(); }
						} else {
						this.$apply(fn);
						}
					};

					// save data matrix for re-slicing as position changes
					// scope.dataMatrix = scope.data;

					// FYI: data == distances
					// eg. particles a=rst,b=uvw,c=xyz
					// give matrix [aa,ab,ac,ba,bb,bc,ca,cb,cc]
					// can be filtered by no. of particles
					// totalMatrixVertices / (totalParticeles * 3)
 					var data = scope.data.distances;
					var focusStart = scope.view.viewpoint.chromStart;
					var focusEnd = scope.view.viewpoint.chromEnd;
					var focusLength = focusEnd - focusStart + 1; // Resrouces.range...
					var particlesCount = scope.settings.current.particlesCount;
					var clipPathUrl = "clip" + scope.title;
					var clipPath = "url(#" + clipPathUrl + ")";

					/* Note: focusLength may not be exactly particlesCount (N) * resolution
					 * BUT for now the last bin resolution is taken as equal to the others
					 * In the future TADbit may output variable bin resolutions
					 * eg. as an array of resolutions corresponding to the bins/particles
					 * Then the code commented below can be developed/completed
					 * to assess and assign the last index of data
					 * This may be better done externally to the track modules
					 * and the results accessed through, for example, view.settings.resolutions
					 */
					// var resolution = scope.view.resolution;
					// var particlesCount = focusLength / resolution;
					// var exactCount = function(particlesCount) { return parseInt(particlesCount) === particlesCount };
					// var resolutionParticleN = exactCount;
					// if (!exactCount) resolutionParticleN = focusLength - (resolution * (n-1));
					// var particles = Math.ceil(particlesCount);

					// SVG GENERATION
					var componentMargin = parseInt(scope.view.settings.margin);
					/* Rebuild margin to maintain D3 standard */
					var margin = {
							top: parseInt(scope.view.settings.padding.top),
							right: parseInt(scope.view.settings.padding.right),
							bottom: parseInt(scope.view.settings.padding.bottom),
							left: parseInt(scope.view.settings.padding.left)
						},
						scale = 4,
						trackHeight = parseInt(scope.view.settings.heightInner),
						nodeHeight = trackHeight * 0.5,
						verticalOffset = (trackHeight - nodeHeight) * 0.5,
						nodePadding = 0,
						nodeColor = scope.view.settings.color;

					// VIEWPORT
					/* component-controller == children[0]
					 * - component-header == children[0]
					 * - component-body == children[3]
					 */
					var component = element[0].parentNode;
					var viewport = element[0].children[0].children[3];
					// if with controller use line below
					// var viewport = element[0].children[0].children[3];
					var svg = d3.select(viewport).append('svg');
					var xScale, xAxis, brush, chart;
					var defs, focus, zoomArea, container, labels, focusGraph, highlight;

					// RESIZE
					scope.$watch(function(){
						var w = component.clientWidth;
						var h = component.clientHeight;
						return w + h;
					}, function() {
						scope.render(data);
					});

					// REDRAW
					scope.$watch('data.dimension', function(newData, oldData) {
						if (newData !== oldData ) {
							data = scope.data.distances;
							scope.render(data);
						}
					});

					// UPDATE
					scope.$watch('settings.current.position', function(newPosition, oldPosition) {
						if ( newPosition !== oldPosition ) {
							scope.update();
						}
					});
					
 				// 	// ZOOM
					// var zoom = d3.behavior.zoom()
					// 	.on("zoom",  function() {
					// 	scope.update();
					// });


					scope.render = function(data) {
						svg.selectAll('*').remove();
 
						if (!data) return;

						var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
							height = trackHeight - margin.top - margin.bottom;
						var particleWidth = (1 * width) / particlesCount;
						xScale = d3.scale.linear()
								.range([0, width])
								.clamp(true);

						xScale.domain([focusStart, focusEnd]);
				
						xAxis = d3.svg.axis()
								.scale(xScale)
								.orient("top")
								.ticks(0)
								.outerTickSize(0);

						var highlightWidth = 2;

						brush = d3.svg.brush()
							.x(xScale)
							.extent([0, 0])
							.on("brush", scope.brushed);

						chart = svg.attr('width', width + margin.left + margin.right)
								.attr('height', height + margin.top + margin.bottom)
								.append("g")
								.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
								.call(brush);
								// .call(zoom);
						
						chart.select(".background")
							.attr("y", height/2)
							.attr("height", height);

						// clipping box to clip overflow
						// solid rect as background also allow mouse events everywhere 
						defs = chart.append("defs")
							.append("clipPath")
							.attr("id", clipPathUrl)
							.append("rect")
							.attr("width", width)
							.attr("height", height)
							.style('fill', 'white');

						focus = chart.append("g")
							.attr("class", "focus");

						// zoomArea = focus.append("g")
						// 	.attr("class", "zoom")
						// 	.append("rect")
						// 	.attr("width", width)
						// 	.attr("height", height)
						// 	.attr('fill', 'white');

						container = focus.append("g")
							.attr("class", "container")
							.attr('clip-path', clipPath);

						labels  = chart.append("g")
							.attr("class", "labels");
	
						focusGraph = container.selectAll("rect")
							.data(data)
							.enter().append("rect")
							.attr("x", function(d, i) { return (i * particleWidth); } )
							.attr("y", verticalOffset)
							.attr("width", particleWidth)
							.attr("height", nodeHeight)
							.style("fill", nodeColor)
							.style("fill-opacity", function(d) { return (d * d); })
							.style("stroke", nodeColor)
							.style("stroke-width", 0)
							.append("svg:title")
								.text(function(d,i) { return i + ":" + d; });

						highlight = chart.append("rect")
								.attr("id", "highlight")
								.attr("x", function(d) { return xScale( scope.settings.current.position); } )
								.attr("y", 0)
								.attr("width", highlightWidth )
								.attr("height", trackHeight)
								.attr("class", "highlight-follow");
						highlight
							.call(brush.extent([(scope.settings.current.position), 0]))
							.call(brush.event);
					};

					// UPDATE
					scope.update = function() {
						svg.select("#highlight") //.style("visibility", "hidden");
						.attr("x", function(d) { return xScale( scope.settings.current.position ); } );
					};

					// BRUSH
					scope.brushed = function() {

						// scope.safeApply( function() {
							var thisTrack = this;
							scope.safeApply( function() {
								var value = brush.extent()[0];
								if (d3.event.sourceEvent) {
									value = parseInt(xScale.invert(d3.mouse(thisTrack)[0]));
									brush.extent([value, value]);
								}
								highlight.attr("x", xScale(value));

								// UPDATE position
								scope.settings.current.position = value;
								scope.settings.current.particle = Settings.getParticle();
								scope.settings.current.segmentLower = scope.settings.current.position - (scope.settings.current.segment * 5); // * 0.5???
								scope.settings.current.segmentUpper = scope.settings.current.position + (scope.settings.current.segment * 5); // * 0.5???

							});
						// });
					};

					// Initial render
					scope.render(data);
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentTrackRestraints', tkComponentTrackRestraints);

	function tkComponentTrackRestraints(d3Service, Settings) {    
		return {
			restrict: 'EA',
			scope: {
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=', /* used in template */
				togglelayer: '&' /* used in template */
			},
			templateUrl: 'assets/templates/track.html',
			link: function(scope, element, attrs) {
				// console.log(scope.data);
				d3Service.load().then(function(d3) {

					scope.safeApply = function(fn) {
						var phase = this.$root.$$phase;
						if(phase == '$apply' || phase == '$digest') {
							if(fn && (typeof(fn) === 'function')) { fn(); }
						} else {
						this.$apply(fn);
						}
					};

 					var data = scope.data;
					var focusStart = scope.view.viewpoint.chromStart;
					var focusEnd = scope.view.viewpoint.chromEnd;
					var focusLength = focusEnd - focusStart + 1; // Resrouces.range...
					var particlesCount = scope.settings.current.particlesCount;
					var clipPathUrl = "clip" + scope.title;
					var clipPath = "url(#" + clipPathUrl + ")";

					// SVG GENERATION
					var componentMargin = parseInt(scope.view.settings.margin);
					/* Rebuild margin to maintain D3 standard */
					var margin = {
							top: parseInt(scope.view.settings.padding.top),
							right: parseInt(scope.view.settings.padding.right),
							bottom: parseInt(scope.view.settings.padding.bottom),
							left: parseInt(scope.view.settings.padding.left)
						},
						scale = 4,
						maxValue = 2,
						trackHeight = parseInt(scope.view.settings.heightInner),
						nodeSize = scope.view.settings.nodeSize,
						verticalOffset = margin.top + (nodeSize * 0.5),
						nodePadding = 0,
						nodeColor = scope.view.settings.color,
						harmonicsColor = scope.layer.palette[0],
						lowerBoundsColor = scope.layer.palette[1];

					// VIEWPORT
					/* component-controller == children[0]
					 * - component-header == children[0]
					 * - component-body == children[3]
					 */
					var component = element[0].parentNode;
					var viewport = element[0].children[0].children[3];
					// if with controller use line below
					// var viewport = element[0].children[0].children[3];
					var svg = d3.select(viewport).append('svg');
					var xScale, axisUpper, axisLower, brush, chart;
					var defs, focus, zoomArea, container, labels, harmonics, lowerBounds, highlight;

					// RESIZE
					scope.$watch(function(){
						var w = component.clientWidth;
						var h = component.clientHeight;
						return w + h;
					}, function() {
						scope.render(scope.data);
					});

					// REDRAW
					scope.$watch('data.dimension', function(newData, oldData) {
						if (newData !== oldData ) {
							data = scope.data;
							scope.render(data);
						}
					});

					// UPDATE
					scope.$watch('settings.current.position', function(newPosition, oldPosition) {
						if ( newPosition !== oldPosition ) {
							scope.update();
						}
					});
					
 				// 	// ZOOM
					// var zoom = d3.behavior.zoom()
					// 	.on("zoom",  function() {
					// 	scope.update();
					// });

					scope.getColor = function(code) {
						var colorCodes = [
											{"type":"harmonic","code":"H","color":"#4CAF50"},
											{"type":"upperBound","code":"L","color":"#0000ff"},
											{"type":"lowerBound","code":"U","color":"#ff00ff"},
											{"type":"contact","code":"C","color":"#00ff00"}
										];
						var color = "#ccc";
						for (var i = colorCodes.length - 1; i >= 0; i--) {
							if (code == colorCodes[i].code) {
								color = colorCodes[i].color;
							}
						}
						return color;
					};

					scope.getOpacity = function(value) {
						var opacity;
						var scaled = value / maxValue; // 5 being the limit...
						opacity = scaled * scaled;
						return opacity;
					};

					scope.getStrokeWidth = function(value) {
						var strokeWidth = 5;
						var scaled = value / 5; // 5 being the limit...
						strokeWidth = strokeWidth * scaled;
						return strokeWidth;
					};

					scope.render = function(data) {
						svg.selectAll('*').remove();
 
						if (!data) return;

						var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right;
						var height = trackHeight - margin.top - margin.bottom;
						var particleWidth = (1 * width) / particlesCount;
						xScale = d3.scale.linear()
								.range([0, width])
								.clamp(true);

						xScale.domain([focusStart, focusEnd]);
				
						axisUpper = d3.svg.axis()
								.scale(xScale)
								.orient("top")
								.ticks(0)
								.outerTickSize(0);

						axisLower = d3.svg.axis()
								.scale(xScale)
								.orient("bottom")
								.ticks(0)
								.outerTickSize(0);

						var highlightWidth = 2;

						brush = d3.svg.brush()
							.x(xScale)
							.extent([0, 0])
							.on("brush", scope.brushed);

						chart = svg.attr('width', width + margin.left + margin.right)
								.attr('height', height + margin.top + margin.bottom)
								.append("g")
								.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
								.call(brush);
								// .call(zoom);
						
						chart.select(".background")
							.attr("y", height/2)
							.attr("height", height);

						// clipping box to clip overflow
						// solid rect as background also allow mouse events everywhere 
						defs = chart.append("defs");

						defs.append("clipPath")
							.attr("id", clipPathUrl)
							.append("rect")
							.attr("width", width)
							.attr("height", height)
							.style('fill', 'white');

						// defs.append("svg:marker")
						// 	.attr("id", "harmonics-marker")
						// 	.attr("viewBox", "0 -3 8 6")
						// 	.attr("refX", 20)
						// 	.attr("refY", 0)
						// 	.attr("markerWidth", 8)
						// 	.attr("markerHeight", 6)
						// 	.attr("orient", "auto")
						//     .append('svg:path')
						// 		.attr('d', "M8,-3 L0,0 L8,6")
						// 		.attr("stroke", harmonicsColor)
						// 		.attr("stroke-width", 1) // get from line?
						// 		.attr('fill', "none");

						// defs.append("svg:marker")
						// 	.attr("id", "lowerbounds-marker")
						// 	.attr("viewBox", "0 -3 8 6")
						// 	.attr("refX", 8)
						// 	.attr("refY", 0)
						// 	.attr("markerWidth", 8)
						// 	.attr("markerHeight", 6)
						// 	.attr("orient", "auto")
						//     .append('svg:path')
						// 		.attr('d', "M0,-3 L8,0 L0,3")
						// 		.attr("stroke", lowerBoundsColor)
						// 		.attr("stroke-width", 1) // get from line?
						// 		.attr('fill', "none");

						focus = chart.append("g")
							.attr("class", "focus");

						harmonics = focus.append("g")
							.attr("class", "harmonics")
							.attr('clip-path', clipPath);

						lowerBounds = focus.append("g")
							.attr("class", "lowerbounds")
							.attr('clip-path', clipPath);

						labels  = chart.append("g")
							.attr("class", "labels");

							// HARMONICS
							// from:
							harmonics.append("rect")
								.attr("x", (data.dimension * particleWidth - (particleWidth)))
								.attr("y", verticalOffset - (nodeSize * 0.5))
								.attr("width", particleWidth)
								.attr("height", nodeSize)
								// .style("stroke", harmonicsColor)
								// .style("stroke-width", 1)
								.style("fill", harmonicsColor)
								.append("svg:title")
									.text(data.dimension);
							// connector:
							harmonics.selectAll("line")
								.data(data.harmonics)
								.enter()
								.append("line")
									.attr("x1", function(d) { return (d[0] * particleWidth - (particleWidth * 0.5)); })
									.attr("y1", verticalOffset)
									.attr("x2", function(d) { return (d[1] * particleWidth - (particleWidth * 0.5)); })
									.attr("y2", height - nodeSize)
									.attr("marker-end", "url(#harmonics-marker)")
									.style("stroke", harmonicsColor)
									.style("opacity", 1)//function(d) { return scope.getOpacity(d[3]); } )
									.style("stroke-width", function(d) { return scope.getStrokeWidth(d[3]); })
									.append("svg:title")
										.text(function(d) { return d[1] + ":" + d[3]; });
							// to:
							// harmonics.selectAll("polygon")
							// 	.data(data.harmonics)
							// 	.enter()
							// 	.append("polygon")
							// 		.attr("points", function(d) {
							// 			var x = (d[1] * particleWidth) - (particleWidth * 0.5);
							// 			var y = height;
							// 			var points = x+","+(y-nodeSize)+" "+(x+(nodeSize*0.5))+","+y+" "+(x-(nodeSize*0.5))+","+y;
							// 			return points;
							// 		} )
							// 		.attr("opacity", function(d) { return scope.getOpacity(d[3]); } )
							// 		.attr("fill", harmonicsColor)
							// 	.append("svg:title")
							// 		.text(function(d) { return d[1] + ":" + d[3]; });
							harmonics.selectAll("circle")
								.data(data.harmonics)
								.enter()
								.append("circle")
									.attr("cx", function(d) { return (d[1] * particleWidth - (particleWidth * 0.5)); })
									.attr("cy", height - nodeSize)
									.attr("r", (nodeSize * 0.5))
									.style("opacity", function(d) { return scope.getOpacity(d[3]); })
									.style("fill", harmonicsColor)
								.append("svg:title")
									.text(function(d) { return d[0] + " : " + d[1]; });

							// LOWERBOUNDS
							// from:
							lowerBounds.append("rect")
								.attr("x", (data.dimension * particleWidth - (particleWidth)))
								.attr("y", (height - (nodeSize * 1.5)))
								.attr("width", particleWidth)
								.attr("height", nodeSize)
								// .style("stroke", lowerBoundsColor)
								// .style("stroke-width", 1)
								.style("fill", lowerBoundsColor)
								.append("svg:title")
									.text(data.dimension);
							// connector:
							lowerBounds.selectAll("line")
								.data(data.lowerBounds)
								.enter()
								.append("line")
									.attr("x1", function(d) { return (d[0] * particleWidth - (particleWidth * 0.5)); })
									.attr("y2", verticalOffset)
									.attr("x2", function(d) { return (d[1] * particleWidth - (particleWidth * 0.5)); })
									.attr("y1", height - nodeSize)
									.attr("marker-end", "url(#lowerbounds-marker)")
									.style("stroke", lowerBoundsColor)
									.style("opacity", function(d) { return scope.getOpacity(d[3]); })
									.style("stroke-width", function(d) { return scope.getStrokeWidth(d[3]); })
									.append("svg:title")
										.text(function(d) { return d[1] + ":" + d[3]; });
							// to:
							// to:
							// lowerBounds.selectAll("polygon")
							// 	.data(data.lowerBounds)
							// 	.enter()
							// 	.append("polygon")
							// 		.attr("points", function(d) {
							// 			var x = (d[1] * particleWidth) - (particleWidth * 0.5);
							// 			var y = verticalOffset - nodeSize;
							// 			var points = x+","+y+" "+(x+(nodeSize*0.5	))+","+(y+nodeSize)+" "+(x-(nodeSize*0.5))+","+(y+nodeSize);
							// 			return points;
							// 		} )
							// 		.attr("opacity", function(d) { return scope.getOpacity(d[3]); } )
							// 		.style("fill", lowerBoundsColor)
							// 	.append("svg:title")
							// 		.text(function(d,i) { return d[1] + ":" + d[3]; });
							lowerBounds.selectAll("circle")
								.data(data.lowerBounds)
								.enter()
								.append("circle")
									.attr("cx", function(d) { return (d[1] * particleWidth - (particleWidth * 0.5)); })
									.attr("cy", verticalOffset)
									.attr("r", (nodeSize * 0.5))
									.style("opacity", function(d) { return scope.getOpacity(d[3]); })
									.style("fill", lowerBoundsColor)
								.append("svg:title")
									.text(function(d) { return d[0] + " : " + d[1]; });

						highlight = chart.append("rect")
								.attr("id", "highlight")
								.attr("x", xScale(scope.settings.current.position))
								.attr("y", 0)
								.attr("width", highlightWidth)
								.attr("height", trackHeight)
								.attr("class", "highlight-follow");
						// highlight
						// 	.call(brush.extent([(scope.settings.current.position), 0]))
						// 	.call(brush.event);
					};

					// UPDATE
					scope.update = function(data) {
						svg.select("#highlight") //.style("visibility", "hidden");
						.attr("x", function(d) { return xScale( scope.settings.current.position ); } );
					};

					// BRUSH
					scope.brushed = function() {

						// scope.safeApply( function() {
							var thisTrack = this;
							scope.safeApply( function() {
								var value = brush.extent()[0];
								if (d3.event.sourceEvent) {
									value = parseInt(xScale.invert(d3.mouse(thisTrack)[0]));
									brush.extent([value, value]);
								}
								highlight.attr("x", xScale(value));

								// UPDATE position
								scope.settings.current.position = value;
								scope.settings.current.particle = Settings.getParticle();
								scope.settings.current.segmentLower = scope.settings.current.position - (scope.settings.current.segment * 5); // * 0.5???
								scope.settings.current.segmentUpper = scope.settings.current.position + (scope.settings.current.segment * 5); // * 0.5???

							});
						// });
					};

					// Initial render
					scope.render(data);
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkComponentTrackSlider', tkComponentTrackSlider);

	function tkComponentTrackSlider(VERBOSE, $log, d3Service, Settings) {
		return {
			restrict: 'EA',
			scope: {
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=', /* used in template */
				togglelayer: '&' /* used in template */
			},
			templateUrl: 'assets/templates/track.html',
			link: function(scope, element, attrs) {
				if (VERBOSE) $log.debug(scope);

				d3Service.load().then(function(d3) {
				
					scope.safeApply = function(fn) {
						var phase = this.$root.$$phase;
						if(phase == '$apply' || phase == '$digest') {
							if(fn && (typeof(fn) === 'function')) { fn(); }
						} else {
						this.$apply(fn);
						}
					};

					// SVG GENERATION
					var data = scope.data;
					var focusStart = scope.view.viewpoint.chromStart;
					var focusEnd = scope.view.viewpoint.chromEnd;
					var cursorWidth = scope.view.settings.cursorWidth;
					var componentMargin = parseInt(scope.view.settings.margin);
					/* Rebuild margin to maintain D3 standard */
					var margin = {
							top: parseInt(scope.view.settings.padding.top),
							right: parseInt(scope.view.settings.padding.right),
							bottom: parseInt(scope.view.settings.padding.bottom),
							left: parseInt(scope.view.settings.padding.left)
						},
						trackHeight = parseInt(scope.view.settings.heightInner);

					// VIEWPORT
					/* component-controller == children[0]
					 * - component-header == children[0]
					 * - component-body == children[3]
					 */
					var component = element[0].parentNode;
						$log.debug(component.clientWidth);
					var viewport = element[0].children[0].children[3];
						$log.debug(viewport.clientWidth);
					// if with controller use line below
					// var viewport = element[0].children[0].children[3];
					var svg = d3.select(viewport).append('svg');
					var slider, xScale, prime3Axis, prime5Axis;
					var handleWidth, handleHeight;
					var xAxis, brush, handle, position;

					// RESIZE
					scope.$watch(function(){
						var w = component.clientWidth;
						var h = component.clientHeight;
						return w + h;
					}, function() {
						scope.render();
					});

					// UPDATE
					scope.$watch('settings.current.position', function(newPosition, oldPosition) {
						if ( newPosition !== oldPosition ) {
							scope.update();
						}
					});
					
 				// 	// ZOOM
					// var zoom = d3.behavior.zoom()
					// 	.on("zoom",  function() {
					// 	scope.update();
					// });

					scope.render = function() {
						svg.selectAll('*').remove();
						
						var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
							height = trackHeight - margin.bottom - margin.top;

						xScale = d3.scale.linear()
								.range([0, width])
								.clamp(true);

						xScale.domain([focusStart, focusEnd]);

						xAxis = d3.svg.axis()
								.scale(xScale)
								.orient("bottom")
								.ticks(4);
							prime3Axis = d3.svg.axis().orient("left");
							prime5Axis = d3.svg.axis().orient("right");
								// .outerTickSize([0]);

						handleWidth = height * 0.5;
						handleHeight = trackHeight;

						brush = d3.svg.brush()
							.x(xScale)
							.extent([0, 0])
							.on("brush", scope.brushed);

						slider = svg.attr("width", width + margin.left + margin.right)
								.attr("height", height + margin.top + margin.bottom)
								.append("g")
								.attr("transform", "translate(" + margin.left + ", " + 0 + ")");

							var labels  = slider.append("g")
								.attr("class", "labels");
								labels.append("text")
									.attr("x", -16)
									.attr("y", 26)
									.style("text-anchor", "right")
									.style("font-size", "10px")
									.text("3'");
								labels.append("text")
									.attr("x", width + 8)
									.attr("y", 26)
									.style("text-anchor", "left")
									.style("font-size", "10px")
									.text("5'");

						var axis = slider.append("g")
							.attr("class", "x axis")
							.attr("transform", "translate(0," + height + ")")
							.call(xAxis)
							.select(".domain")
							.select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
							.attr("class", "halo");

						slider.append("g")
							.attr("class", "slider")
							.call(brush);

						slider.select(".background")
							.attr("y", height/2)
							.attr("height", height);
							
						handle = slider.append("circle")
							.attr("id", "handle")
							.attr("class", "handle")
							.attr("cx", xScale(scope.settings.current.position))
							.attr("cy", height)
							.attr("r", handleWidth * 0.6);

						position = slider.append("text")
							.attr("id", "position")
							.attr("x", xScale(scope.settings.current.position) - (handleWidth * 0.5))
							.attr("y", height - 10)
							.style("text-anchor", "bottom")
							.style("font-family", "sans-serif")
							.style("font-size", "10px")
							.style("color", "#333")
							.text(scope.settings.current.particle);

						slider
							.call(brush.extent([(scope.settings.current.position), 0]))
							.call(brush.event);
					};

					// UPDATE
					scope.update = function(data) {
						svg.select("#handle") //.style("visibility", "hidden");
						.attr("cx", xScale(scope.settings.current.position) );
						svg.select("#position") //.style("visibility", "hidden");
						.attr("x", (xScale(scope.settings.current.position) - (handleWidth * 0.5)) )
						.text(scope.settings.current.particle);
					};

					// BRUSH
					scope.brushed = function() {
						// scope.safeApply( function() {
							var thisSlider = this;
							scope.safeApply( function() {
								var value = brush.extent()[0];
								if (d3.event.sourceEvent) {
									value = parseInt(xScale.invert(d3.mouse(thisSlider)[0]));
									brush.extent([value, value]);
								}
								handle.attr("cx", xScale(value));

								// UPDATE position
								scope.settings.current.position = value;
								scope.settings.current.particle = Settings.getParticle();
								scope.settings.current.segment = Settings.getSegment();
								scope.settings.current.segmentLower = scope.settings.current.position - (scope.settings.current.segment * 5); // * 0.5???
								scope.settings.current.segmentUpper = scope.settings.current.position + (scope.settings.current.segment * 5); // * 0.5???

							});
						// });
					};

				});
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkTooltip
	 * @scope
	 * @restrict EA
	 *
	 * @description
	 * Track Tooltip.
	 *
	 * @example
	 * `<tk-tooltip title="title" contents="contents"/>`
	 * `<div tk-tooltip title="title" contents="contents"></div>`
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkTooltip', tkTooltip);

	function tkTooltip($timeout) {    
		return {
			restrict: 'EA',
			scope: {
				title: '=',
				content: '=',
				sorting: '=',
				styling: '='
			},
			templateUrl: 'assets/templates/track-tooltip.html',
			link: function(scope, element, attrs) {
				if (scope.content) {

					scope.title.replace('_name','');
					var height = angular.element(element).prop('offsetHeight');

					scope.$watch(function() {
							height = angular.element(element).prop('offsetHeight');
							angular.element(element).css("top", "-" + height + "px");
					});

					var width = scope.styling.width;
					var padding = scope.styling.padding;
					var center = (width * 0.5) - (padding * 0.5);
					var background = scope.styling.background;

					// STYLES applied to template via ng-style
					element.css({
						"position" : "absolute",
						"display" : "block",
						"background" : background,
						"color" : "white",	
						"border-radius" : padding + "pxÃ±    ",
						"padding" : padding + "px",
						"width" : width + "px",
						"opacity" : 0,
						"z-index" : 2,
					});
					scope.tkTooltipTitle = {
					    "font-weight" : "bold",
					    "margin-bottom" : "10px",
					    "text-transform" : "capitalize"
					};
					scope.tkTooltipContent = {
						"font-size" : "0.7rem"
					};
					scope.tkTooltipList = {
					};
					scope.tkTooltipTerm = {
						"float" : "left",
						"clear" : "left",
						"width": "50px",
						"font-weight": "bold"
					};
					scope.tkTooltipDescription = {
						"margin" : "0 0 0 50px",
						"padding" : "0 0 0.2em 0"
					};
					scope.tkTooltipArrow = {
					    "position" : "absolute",
					    "bottom" : "-" + padding + "px",
					    "left" : center + "px",
					    "width" : 0,
					    "height" : 0, 
					    "border-right" : padding + "px solid transparent",
					    "border-left" : padding + "px solid transparent",
					    "border-top" : padding + "px solid " + background,
					    "font-size" : 0,
					    "line-height" : 0
					};
				}
			}
		};
	}
})();
(function() {
	'use strict';
	/**
	 * @ngdoc directive
	 * @name TADkit.directive:tkComponentWiggle0
	 * @scope
	 * @restrict EA
	 *
	 * @description
	 * Track component which generates a d3 graph
	 * from supplied BigWig (wiggle format) data.
	 *
	 * @example
	 * `<div tk-component-wiggle0 type="component.object.type" title="component.object.title" settings="settings" view="component.view" data="component.data" layer="component.layer" togglelayer="toggleLayer(index)"></div>`
	 *
	 */
	angular
		.module('TADkit')
		.directive('tkComponentWiggle0', tkComponentWiggle0);

	function tkComponentWiggle0(VERBOSE, $log, d3Service) {    
		return {
			restrict: 'EA',
			scope: {
				type: '=',
				title: '@',
				settings: '=',
				view: '=',
				data: '=',
				layer: '=', /* used in template */
				togglelayer: '&' /* used in template */
			},
			templateUrl: 'assets/templates/track.html',
			link: function(scope, element, attrs) {
				d3Service.load().then(function(d3) {
					if (VERBOSE) $log.debug(scope);

 					// DATA MANIPULATION >>> MOVE TO CONTROLLER
					var data = scope.data;
					// var assemblyLength = 3200000000; // CALCULATE
					// if (!scope.settings.current.position) scope.settings.current.position = assemblyLength / 2;
					var step = scope.view.settings.step;
					var stepWidth;
					var focusStart = scope.view.viewpoint.chromStart;
					var focusEnd = scope.view.viewpoint.chromEnd;
					// var chrStart = 0;
					// var chrEnd = assemblyLength;
					var focusLength = focusEnd - focusStart;
					// var highlightPosition = focusStart + (stepWidth * scope.settings.current.position);

					// var focusScale = assemblyLength / focusLength;
					// var focusMargin = focusScale * 0.05;
					// focusScale = focusScale - (focusMargin * 2.0);
		
					// var focusCenter = focusLength * 0.5;
					// var assemblyCenter = assemblyLength * 0.5;


					// SVG GENERATION
					var componentMargin = parseInt(scope.view.settings.margin);
					/* Rebuild margin to maintain D3 standard */
					var margin = {
							top: parseInt(scope.view.settings.padding.top),
							right: parseInt(scope.view.settings.padding.right),
							bottom: parseInt(scope.view.settings.padding.bottom),
							left: parseInt(scope.view.settings.padding.left)
						},
						scale = 4,
						trackHeight = parseInt(scope.view.settings.heightInner),
						nodeHeight = trackHeight * 0.5,
						verticalOffset = (trackHeight - nodeHeight) * 0.5,
						nodePadding = 0,
						nodeColor = scope.view.settings.color;

					// VIEWPORT
					/* component-controller == children[0]
					 * - component-header == children[0]
					 * - component-body == children[3]
					 */
					var component = element[0].parentNode;
					var viewport = element[0].children[0].children[3];
					// if with controller use line below
					// var viewport = element[0].children[0].children[3];
					var svg = d3.select(viewport).append('svg');
					var chart, defs;
					var xAxis, prime3Axis, prime5Axis;
					var focus, container, xScale;

					// RESIZE implies complete redraw
					scope.$watch(function(){
						var w = component.clientWidth;
						var h = component.clientHeight;
						return w + h;
					}, function() {
						scope.render(data);
					});

					// REDRAW on new data
					// scope.$watch('data', function(newData) {
					// 	scope.render(newData);
					// }, true);
 					
					// SLIDER
					scope.$watch('settings.current.position', function(newData) {
						scope.update();
					}, true);

 					// ZOOM
					var zoom = d3.behavior.zoom()
						.on("zoom",  function() {
						scope.update();
					});

					/**
					 * @ngdoc function
					 * @name TADkit.directive:tkComponentWiggle0#render
					 * @methodOf TADkit.directive:tkComponentWiggle0
					 * @kind function
					 *
					 * @description
					 * Initial render of d3.js graph
					 *
					 * @param {Object} Data A colleciton of .
					 * @returns {Object} A d3.js Object.
					 */
					scope.render = function(data) {
						svg.selectAll('*').remove();
 
						if (!data) return;
 
							var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
								height = trackHeight - margin.top - margin.bottom;
							stepWidth = (step * width) / focusLength;
							xScale = d3.scale.linear()
									.range([0, width])
									.clamp(true);

							xScale.domain([focusStart, focusEnd]);
					
							xAxis = d3.svg.axis()
									.scale(xScale)
									.orient("top")
									.ticks(0)
									.outerTickSize(0);
							// prime3Axis = d3.svg.axis().orient("left"),
							// prime5Axis = d3.svg.axis().orient("right");

							var highlightWidth = 2; //stepWidth;// * width / focusLength;
							// if (highlightWidth < 4) highlightWidth = 4; 
							// var focusOffset = xScale(assemblyCenter) - xScale(focusCenter);

							chart = svg.attr('width', width + margin.left + margin.right)
									.attr('height', height + margin.top + margin.bottom)
									.append("g")
									.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
									// .call(zoom);
							
							// clipping box to clip overflow
							// solid rect as background also allow mouse events everywhere 
							defs = chart.append("defs")
								.append("clipPath")
									.attr("id", "clip")
								.append("rect")
									.attr("width", width)
									.attr("height", height)
									.style('fill', 'white');

							focus = chart.append("g")
								.attr("class", "focus");

							// var zoomArea = focus.append("g")
							// 	.attr("class", "zoom")
							// 	.append("rect")
							// 	.attr("width", width)
							// 	.attr("height", height)
							// 	.attr('fill', 'white');

							container = focus.append("g")
								.attr("class", "container")
								.attr('clip-path', 'url(#clip)');

							// zoom.x(xScale);

							// chart.select(".focus").append("g")
							// 	.attr("class", "x axis")
							// 	.attr("transform", "translate(0," + nodeHeight + ")");
								// .call(xAxis);

							var labels  = chart.append("g")
								.attr("class", "labels");

							// TODO: Use FontAwesome/IcoMoon...
							// node.append('text')
							//     .attr('font-family', 'FontAwesome')
							//     .attr('font-size', function(d) { return d.size+'em'} )
							//     .text(function(d) { return '\uf118' }); 

							var focusGraph = container.selectAll("rect")
								.data(data)
								.enter().append("rect")
									.attr("x", function(d, i) { return (i + 1) * stepWidth; } )
									.attr("y", verticalOffset)
									.attr("width", stepWidth)
									.attr("height", nodeHeight)
									.style("fill", nodeColor)
									.style("fill-opacity", function(d) { return d; })
									.style("stroke", nodeColor)
									.style("stroke-width", 0)
									.append("svg:title")
										.text(function(d,i) { return i + ":" + d; });

							var highlight = chart.append("rect")
									.attr("id", "highlight")
									.attr("x", function(d) { return xScale( scope.settings.current.position - (step * 0.5)); } )
									.attr("y", 0)
									.attr("width", highlightWidth )
									.attr("height", trackHeight)
									.attr("class", "highlight-follow");
					};

					/**
					 * @ngdoc function
					 * @name TADkit.directive:tkComponentWiggle0#update
					 * @methodOf TADkit.directive:tkComponentWiggle0
					 * @kind function
					 *
					 * @description
					 * Updates d3.js graph
					 *
					 */
					scope.update = function() {
						// 	var width = component.clientWidth - (2 * componentMargin) - margin.left - margin.right,
						// 		height = trackHeight - margin.top - margin.bottom;
						// 	stepWidth = (step * width) / focusLength;

						// svg.select("g.x.axis").call(xAxis);
						// container.selectAll("rect")
						// .attr("x", function(d, i) { return (i + 1) * stepWidth; } )	
						// .attr("y", verticalOffset)
						// .attr("width", stepWidth)
						// .attr("height", nodeHeight);

						svg.select("#highlight") //.style("visibility", "hidden");
						.attr("x", function(d) { return xScale( scope.settings.current.position - (step * 0.5)); } );
					};
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('TrackController', TrackController);

	function TrackController($log, $scope) {
		// if ($scope.layer) {
		// 	$log.debug($scope.layer.object.id);
		// 	$log.debug($scope.layer.object.state.overlaid);
		// 	$scope.overlaid = $scope.layer.object.state.overlaid;
		// 	$scope.layerOrig = Layers.getLayer(); // current layer
		// 	$scope.toggleLayer = function(index) {
		// 		$scope.overlaid = Layers.getLayer(index).object.state.overlaid;
		// 		if (!$scope.overlaid) {
		// 			Layers.setOverlaid(index);
		// 			Layers.set(index);
		// 		} else {
		// 			Layers.setOverlaid($scope.layerOrig.object.state.index);
		// 			Layers.set($scope.layerOrig.object.state.index);
		// 		}
		// 		$scope.overlaid = !$scope.overlaid;
		// 	};
		// }

		$scope.optionsState = false;
		$scope.toggleOptions = function() {
			$scope.optionsState = !$scope.optionsState;
		};

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('DataImportController', DataImportController);

	function DataImportController ($log, $state, $scope, $mdDialog, $mdToast, DataImport, Datasets, Layers) {
		$scope.fileTitle = "No file loaded";

		$scope.$on('$viewContentLoaded', function() {
			var parentElement = angular.element(document.body);
			var stateTemplate = "assets/templates/" + $state.current.name + ".html";
			// Import Layers Dialog
			$mdDialog.show({
				parent: parentElement,
				templateUrl: stateTemplate,
				controller: DataImportController,
				locals: {
					layers: $scope.$parent.layers,
				},
				onComplete: afterShowAnimation
			}).then(function(datasetTitle) {
				$log.info("Dataset \"" + datasetTitle + "\" added.");
			}, function() {
				$log.log("Layers import cancelled. No tracks added.");
	 			$state.go('browser');	
			});
			// When the 'enter' animation finishes...
			function afterShowAnimation(scope, element, options) {
				// post-show code here: DOM element focus, etc.
				$log.debug(scope);
				$log.debug("Showing dialog");
			}
		});

		// Parse $fileContent user preview in modal window
		$scope.previewData = function($fileContent) {
			$log.info("Previewing...");
			$scope.preview = Datasets.preview($fileContent);
			$log.info("Data fetched - pending selection...");
		};

		// TODO message on sucess/fail in Layers.import
		$scope.importData = function() {
			$log.info("Import selected data...");
			var importedData = Datasets.import($scope.preview);
			$log.info("Import complete.");
			$mdDialog.hide(importedData.object.title);
			$state.go('browser');
		};

		$scope.cancel = function() {
			$mdDialog.cancel();
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.directive('tkDataImport', tkDataImport);

	function tkDataImport($log, $parse) {		
		return {
			restrict: 'A',
			scope: {
				tkDataImport : "&",
				filetitle : "="
			},
			link: function(scope, element, attrs) {
				element.on('change', function(e) {
					var reader = new FileReader();
					reader.onload = function(e) {
						scope.$apply(function() {
							$log.debug("Fetching Import results....");
							scope.tkDataImport({$fileContent:e.target.result});
						});
					};
					reader.readAsText((e.srcElement || e.target).files[0]);
					scope.filetitle = (e.srcElement || e.target).files[0].name;
				});
			}
		};
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('SidebarBrowserController', SidebarBrowserController);

	function SidebarBrowserController ($log, $scope, Settings){

		// Model Settings
		$scope.toggleSetting = function(setting) {
			$scope.settings = Settings.toggle(setting); // update $scope.settings defined in browser controller
		};

		// Scene Settings
		// $scope.toggleScene = function(scene) {
		// 	$scope.scenes = Scenes.toggle(scene); // update $scope.scenes defined in browser controller
		// };

		// Track layers
		// $scope.toggleTrack = function(track) {
		// 	$log.debug(track);
		// 	$scope.tracks = Tracks.toggle(track); // update $scope.tracks defined in browser controller
			// $scope.colors = $scope.colors; // CHANGE OF COLOR USED BY SCENE DONE IN SCENE CONTROLLER ie. Here only set current color
		// };
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('StoryboardController', StoryboardController);

	function StoryboardController($log, $window, $scope, Settings, Storyboards, Components, Layers, Proximities, Restraints) {

		// WATCH FOR WINDOW RESIZE
		angular.element($window).on('resize', function(){ $scope.$apply(); });

		// Â¿Â¿Â¿ SET segmentLength??? $scope.current.storyboard.components[0].view.settings.chromatin.segmentLength = $scope.settings.current.segmentLength;

		$scope.settings.views.scale = 1; //$scope.current.dataset.object.scale;
		// one of the setViewpoints is redundant?
		Storyboards.setViewpoint();
		// Components.setViewpoint();

		// Calculating Initial Proximities
		//NOTE in future if more than 1 currentModel need same number of currentProximities
		$scope.allProximities = Proximities.get(); // for Scene
		$scope.currentProximities = Proximities.get($scope.settings.current.particle); // for D3 tracks

		// Calculating Initial Restraints
		//NOTE in future if more than 1 currentModel need same number of currentRestraints
		$scope.currentRestraints = Restraints.get($scope.settings.current.particle); // for D3 tracks
		// console.log($scope.currentRestraints);
		// Assign data and layers for each component by type
		$scope.components = Storyboards.getComponents();
		angular.forEach( $scope.components, function(component, index) {

			// if (component.object.dataset == "default") {
				var layer, layerProximities;
				if (component.object.type == "scene") {
					component.data = $scope.current.model.data;
					 // component.proximities required for Scenes: layer.colors Saturation
					component.proximities = $scope.allProximities;
					component.layer = $scope.current.layer;
					component.layer.state = {};
					component.layer.object.state.index = Layers.getCurrentIndex();
				} else if (component.object.type == "track-genes" || component.object.type == "panel-inspector") {
					layer = Layers.getLayerById("genes");
					component.data = layer.data;
					// component.layer required for toggle
					component.layer = layer;
				} else if (component.object.type == "track-proximities") {
					// ie only one... see note above for Calculating Proximities
					// component.data for Scenes: layer.colors Saturation
					component.data = $scope.currentProximities;
					// component.layer required for toggle
					//   and for Scenes: layer.colors Hue
					layer = Layers.getLayerById("proximities");
					component.layer = layer;
				} else if (component.object.type == "track-restraints") {
					// ie only one... see note above for Calculating Restraints
					// component.data for Scenes: layer.colors Saturation
					component.data = $scope.currentRestraints;
					// component.layer required for toggle
					//   and for Scenes: layer.colors Hue
					layer = Layers.getLayerById("restraints");
					component.layer = layer;
				}
				// } else if (component.object.type == "track-wiggle") {
				// 	layer = Layers.getLayerById(component.object.dataset);
				// 	component.data = layer.data;
				// 	component.layer = layer; // required for toggle
				// } else {
				// 	// slider and other types of component...
				// }
			// }
		});

		// Watch for Slider Position updates
		$scope.$watch('settings.current.particle', function(newParticle, oldParticle) { // deep watch as change direct and changes all?
			if ( newParticle !== oldParticle ) {
				$scope.currentProximities = Proximities.get(newParticle); // for D3 tracks
				$scope.currentRestraints = Restraints.get(newParticle); // for D3 tracks
				if ($scope.current.layer.object.type == "matrix") {
					Layers.at(newParticle);
					$scope.current.layer = Layers.getLayer();
				} 
				$log.debug($scope.currentProximities);
			}
		});

		// save original overlaid
		$scope.layerOrig = $scope.current.layer;
		$scope.toggleLayer = function(index) {
			$scope.overlaid = Layers.getLayer(index).object.state.overlaid;
			if (!$scope.overlaid) {
				Layers.setOverlaid(index);
				Layers.set(index);
				$scope.current.layer = Layers.getLayer();
				$log.debug($scope.current.layer);
			} else {
				Layers.setOverlaid($scope.layerOrig.object.state.index);
				Layers.set($scope.layerOrig.object.state.index);
				$scope.current.layer = Layers.getLayer();
			}
			// $scope.layer.object.state.overlaid = !$scope.layer.object.state.overlaid;
		};

		$scope.optionsState = false;
		$scope.toggleOptions = function() {
			$scope.optionsState = !$scope.optionsState;
		};

		$scope.toggle = function(bool) {
			bool = !bool;
			$log.debug(bool);
		};

		$scope.testfn = function() {
			$log.debug("test worked");
		};

		// $scope.keyControls = function (e, component) {
		// 	if (event.keyCode === 32 || event.charCode === 32) {
		// 		component.view.controls.autoRotate = !component.view.controls.autoRotate; 
		// 	}
		// };

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('HomeController', HomeController);

	function HomeController ($scope){

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('ProjectDatasetController', ProjectDatasetController);

	function ProjectDatasetController ($log, $state, $scope, Clusters, Layers, Components, Segments){
		$log.debug($scope);

		// Get dataset clusters scene component
		$scope.clusterComponent = Components.getComponentById("dataset-clusters");

		// Set cluster color to gradient
		// Recalculate specifically for single segment per particle in cluster scene
		var gradientLayer = Layers.getLayerById("gradient");
		var clusterLength = $scope.current.model.data.length / $scope.current.dataset.object.components;
		var gradientColors = Segments.gradientHCL(gradientLayer, clusterLength);
		$scope.clusterComponent.layer = gradientColors;

		// Calculate consistent camera position (translation) from combined dataset models
		var datasetModels = new THREE.BufferGeometry();
		for (var h = $scope.current.dataset.models.length - 1; h >= 0; h--) {
			datasetModels.addAttribute( 'position', new THREE.BufferAttribute( $scope.current.dataset.models[h].data, 3 ) );
		}
		datasetModels.computeBoundingSphere();
		$log.debug(datasetModels.boundingSphere.center);
		$log.debug(datasetModels.boundingSphere.radius);
		$scope.clusterComponent.view.viewpoint.camera = datasetModels.boundingSphere.center;
		$scope.clusterComponent.view.viewpoint.target = datasetModels.boundingSphere.center;
		$scope.clusterComponent.view.viewpoint.translate = datasetModels.boundingSphere.radius * datasetModels.boundingSphere.scale;

		// Create collection of cluster models
		$scope.clusters = Clusters.get();
		$log.debug($scope.clusters);

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('ProjectLoaderController', ProjectLoaderController);

	function ProjectLoaderController($log, $q, $state, $stateParams, $scope, Datasets, Clusters, Layers, Storyboards) {

		$scope.updateCurrent = function() {
			$scope.current.dataset = Datasets.getDataset();
			$scope.current.model = Clusters.getModel();
			$scope.current.layer = Layers.getLayer();
			$log.info("Current dataset, model, layer and storyboard updated.");			
		};

		// On click load dataset from URL Params
		// Loads local JSON and then associated TSV tracks from /examples folder
		$scope.loadDatasetFromParam = function() {
			var loading = Datasets.load($stateParams.loadDataset);
			return $q.all([ loading ])
			.then(function(results){
				$scope.updateCurrent();
				$log.info("Dataset loaded: " + $stateParams.loadDataset);			
				$state.go('browser');
			});
		};
		if ($stateParams.loadDataset) $scope.loadDatasetFromParam();

		// On dropzone (load external file)
		// Adds JSON to current project - load TSV when in browser
		$scope.addDataset = function($fileContent) {
			var adding = Datasets.import($fileContent);
			return $q.all([ adding ])
			.then(function(results){
				$scope.updateCurrent(); // NEEDED? Move to function in Settings Service???
				// ADD FILENAME (SEE data-import)
				$log.info("Dataset added."); //: " + $stateParams.loadDataset);			
				$state.go('dataset');
			});
		};		
	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('ProjectController', ProjectController);

	function ProjectController($scope, Datasets, Layers, Storyboards) {

		$scope.setCurrentDataset = function(index) {
			Datasets.set(index);
		};
		$scope.setCurrentLayer = function(index) {
			Layers.set(index);
		};
		$scope.setCurrentStoryboard = function(index) {
			Storyboards.set(index);
		};

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('MainController', MainController);

	function MainController($state, $stateParams, $scope, Settings, Users, Projects, Datasets, Clusters, Layers, Storyboards) {
		// Check if first load
		if (!$scope.settings) {
			$scope.settings = Settings.get();
		}
		// Review utility of isProject
		$scope.settings.app.isProject = $state.is('project');
		$scope.$on("$stateChangeSuccess", function updatePage() {
			$scope.settings.app.isProject = $state.is('project');
		});

		// SET SHARED CURRENT PROJECT LEVEL DATA
		$scope.current = {};
		$scope.current.dataset = Datasets.getDataset();
		$scope.current.model = Clusters.getModel();
		$scope.current.layer = Layers.getLayer();

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('SidebarUserController', SidebarUserController);

	function SidebarUserController ($scope){

		// // User Profile
		// $scope.user = function(user) {
		// 	$scope.user.profile = Settings.getProfile(user);
		// };

	}
})();
(function() {
	'use strict';
	angular
		.module('TADkit')
		.controller('TopbarController', TopbarController);

	function TopbarController($state, $scope, $mdSidenav) {

		$scope.$state = $state;
		// if ($state.includes('main.project')){
		// 	$scope.projectTitle = $scope.users[0].projects[0].object.title;
		// }

		$scope.toggleLeft = function() {
			$mdSidenav('left').toggle();
		};

		$scope.toggleRight = function() {
			$mdSidenav('right').toggle();
		};
	}
})();